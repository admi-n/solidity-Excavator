<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/internal/handler/mode1_targeted.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/handler/mode1_targeted.go" />
              <option name="originalContent" value="package handler&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/config&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/ai&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/strategy/prompts&quot;&#10;&#9;&quot;strings&quot;&#10;)&#10;a&#10;// RunMode1Targeted 执行 Mode1 定向扫描&#10;func RunMode1Targeted(cfg internal.ScanConfig) error {&#10;&#9;fmt.Println(&quot; 启动 Mode1 定向漏洞扫描...&quot;)&#10;&#10;&#9;// 1. 初始化数据库&#10;&#9;db, err := config.InitDB()&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;初始化数据库失败: %w&quot;, err)&#10;&#9;}&#10;&#9;defer db.Close()&#10;&#10;&#9;// 2. 创建 AI 管理器&#10;&#9;aiManager, err := ai.NewManager(ai.ManagerConfig{&#10;&#9;&#9;Provider:       cfg.AIProvider,&#10;&#9;&#9;Timeout:        cfg.Timeout,&#10;&#9;&#9;RequestsPerMin: 20, // 每分钟 20 个请求&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;创建 AI 管理器失败: %w&quot;, err)&#10;&#9;}&#10;&#9;defer aiManager.Close()&#10;&#10;&#9;// 3. 测试 AI 连接&#10;&#9;ctx := context.Background()&#10;&#9;if err := aiManager.TestConnection(ctx); err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;AI 连接测试失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 4. 加载 prompt 模板&#10;&#9;promptTemplate, err := prompts.LoadTemplate(cfg.Mode, cfg.Strategy)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;加载 prompt 模板失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 4.1 尝试加载 EXP 代码（如果存在）&#10;&#10;&#9;// 5. 获取目标合约地址&#10;&#9;var targetAddresses []string&#10;&#9;switch cfg.TargetSource {&#10;&#9;case &quot;db&quot;:&#10;&#9;&#9;targetAddresses, err = getAddressesFromDB(db, cfg.BlockRange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;从文件获取地址失败: %w&quot;, err)&#10;&#9;&#9;targetAddresses, err = getAddressesFromFile(cfg.TargetFile)&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;缺少目标合约地址: -t-address&quot;)&#10;&#9;&#9;targetAddresses = []string{strings.TrimSpace(cfg.TargetAddress)}&#10;&#9;&#9;if strings.TrimSpace(cfg.TargetAddress) == &quot;&quot; {&#10;&#9;&#9;}&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;缺少目标合约地址: -t-address&quot;)&#10;&#9;&#9;} else {&#10;&#9;&#9;if cfg.TargetAddress != &quot;&quot; {&#10;&#9;case &quot;contract&quot;, &quot;address&quot;:&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;从文件获取地址失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;default:&#10;&#9;&#9;return fmt.Errorf(&quot;不支持的目标源: %s&quot;, cfg.TargetSource)&#10;&#9;}&#10;&#10;&#9;fmt.Printf(&quot; 共找到 %d 个目标合约\n&quot;, len(targetAddresses))&#10;&#10;&#9;// 注意: Downloader 没有公开 Close 方法，故不调用 downloader.Close()&#10;&#9;&#9;fmt.Println(&quot;⚠️  没有找到可扫描的合约&quot;)&#10;&#9;results := make([]*ScanResult, 0, len(targetAddresses))&#10;&#9;}&#10;&#10;&#9;// 6. 创建下载器（用于获取合约代码）&#10;&#9;downloader, err := download.NewDownloader(db, &quot;&quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;创建下载器失败: %w&quot;, err)&#10;&#9;}&#10;&#9;defer downloader.Close()&#10;&#10;&#9;// 7. 处理每个合约&#10;&#9;results := make([]*ScanResult, 0)&#10;&#9;successCount := 0&#10;&#9;failCount := 0&#10;&#10;&#9;for i, address := range targetAddresses {&#10;&#9;&#9;fmt.Printf(&quot;\n[%d/%d] 处理合约: %s\n&quot;, i+1, len(targetAddresses), address)&#10;&#10;&#9;&#9;// 7.1 获取合约代码&#10;&#9;&#9;contractCode, err := getOrDownloadContract(ctx, db, downloader, address)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;⚠️  获取合约代码失败: %v，跳过\n&quot;, err)&#10;&#9;&#9;&#9;failCount++&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 检查是否为字节码（以 0x 开头且全是十六进制）&#10;&#9;&#9;if isOnlyBytecode(contractCode) {&#10;&#9;&#9;&#9;fmt.Println(&quot;  ⏭️  合约未开源（仅字节码），跳过分析&quot;)&#10;&#9;&#9;&#9;failCount++&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 7.2 构建 prompt（使用专门的 Mode1 构建器）&#10;&#9;&#9;var prompt string&#10;&#9;&#9;if expCode != &quot;&quot; {&#10;&#9;&#9;&#9;// 如果有 EXP 代码，使用完整的 Mode1 prompt&#10;&#9;&#9;&#9;prompt = prompts.BuildMode1Prompt(address, contractCode, cfg.Strategy, expCode)&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;// 否则使用基础模板&#10;&#9;&#9;&#9;prompt = prompts.BuildPrompt(promptTemplate, map[string]string{&#10;&#9;&#9;&#9;&#9;&quot;ContractAddress&quot;: address,&#10;&#9;&#9;&#9;&#9;&quot;ContractCode&quot;:    contractCode,&#10;&#9;&#9;&#9;&#9;&quot;Strategy&quot;:        cfg.Strategy,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 7.3 调用 AI 分析&#10;&#9;&#9;analysisResult, err := aiManager.AnalyzeContract(ctx, contractCode, prompt)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;⚠️  AI 分析失败: %v，跳过\n&quot;, err)&#10;&#9;&#9;&#9;failCount++&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;// 打印漏洞摘要&#10;&#9;&#9;// 7.4 保存结果&#10;&#9;&#9;scanResult := &amp;ScanResult{&#10;&#9;&#9;&#9;Address:        address,&#10;&#9;}&#10;&#9;&#9;&#9;Timestamp:      time.Now(),&#10;&#9;fmt.Printf(&quot;\n%s\n&quot;, strings.Repeat(&quot;=&quot;, 50))&#10;&#9;&#9;&#9;Strategy:       cfg.Strategy,&#10;&#9;&#9;}&#10;&#9;&#9;results = append(results, scanResult)&#10;&#9;&#9;successCount++&#10;&#9;fmt.Printf(&quot;%s\n\n&quot;, strings.Repeat(&quot;=&quot;, 50))&#10;&#9;fmt.Printf(&quot;\n%s\n&quot;, strings.Repeat(&quot;=&quot;, 50))&#10;&#9;&#9;printVulnerabilitySummary(scanResult)&#10;&#10;&#9;&#9;// 避免请求过快&#10;&#9;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;fmt.Printf(&quot;%s\n\n&quot;, strings.Repeat(&quot;=&quot;, 50))&#10;&#10;&#9;// 8. 打印总结&#10;&#9;fmt.Printf(&quot;\n&quot; + &quot;=&quot;.repeat(50) + &quot;\n&quot;)&#10;&#9;fmt.Printf(&quot;✅ 扫描完成！\n&quot;)&#10;&#9;fmt.Printf(&quot;   - 总合约数: %d\n&quot;, len(targetAddresses))&#10;&#9;fmt.Printf(&quot;   - 成功分析: %d\n&quot;, successCount)&#10;&#9;fmt.Printf(&quot;   - 失败/跳过: %d\n&quot;, failCount)&#10;&#9;fmt.Printf(&quot;   - 发现漏洞的合约: %d\n&quot;, countVulnerableContracts(results))&#10;&#9;fmt.Printf(&quot;=&quot;.repeat(50) + &quot;\n\n&quot;)&#10;&#9;if len(code) &gt;= 2 &amp;&amp; code[:2] != &quot;0x&quot; {&#10;&#9;// 9. 生成报告&#10;&#9;if len(results) &gt; 0 {&#10;&#9;&#9;if err := generateReport(results, cfg); err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;生成报告失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;if len(code) &gt;= 2 &amp;&amp; code[:2] != &quot;0x&quot; {&#10;&#9;return nil&#10;}&#10;&#10;// isOnlyBytecode 检查是否为纯字节码（未开源）&#10;&#9;if len(code) &lt; 10 {&#10;&#9;&#9;return true&#10;&#9;}&#10;&#9;// 检查是否以 0x 开头且只包含十六进制字符&#10;&#9;if code[:2] != &quot;0x&quot; {&#10;&#9;&#9;return false&#10;&#9;}&#10;&#9;for _, c := range code[2:] {&#10;&#9;&#9;if !((c &gt;= '0' &amp;&amp; c &lt;= '9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F')) {&#10;&#9;&#9;&#9;return false&#10;&#9;&#9;}&#10;}&#10;&#10;// getOrDownloadContract 从数据库获取合约代码，如果不存在则下载&#10;func getOrDownloadContract(ctx context.Context, db *sql.DB, downloader *download.Downloader, address string) (string, error) {&#10;&#9;// 先尝试从数据库获取（注意：字段名是 contract 而不是 source_code）&#10;&#9;var contractCode string&#10;&#9;query := &quot;SELECT contract FROM contracts WHERE address = ? AND contract IS NOT NULL AND contract != ''&quot;&#10;&#9;err := db.QueryRow(query, address).Scan(&amp;contractCode)&#10;&#10;&#9;if err == nil &amp;&amp; contractCode != &quot;&quot; {&#10;&#9;&#9;fmt.Println(&quot;  ✓ 从数据库读取合约代码&quot;)&#10;&#9;&#9;return contractCode, nil&#10;&#9;}&#10;&#10;&#9;// 数据库中不存在，尝试下载&#10;&#9;fmt.Println(&quot;  ↓ 合约不在数据库中，正在下载...&quot;)&#10;&#10;&#9;// 使用下载器获取合约&#10;&#9;if err := downloader.DownloadContractsByAddresses(ctx, []string{address}, &quot;&quot;); err != nil {&#10;&#9;&#9;return &quot;&quot;, fmt.Errorf(&quot;下载合约失败: %w&quot;, err)&#10;&#10;&#9;&#9;&#9; LIMIT 1000`&#10;&#9;&#9;&#9; AND isopensource = 1&#10;&#9;&#9;&#9; AND contract IS NOT NULL AND contract != ''&#10;&#9;&#9;&#9; LIMIT 1000`&#10;&#9;&#9;&#9; AND isopensource = 1&#10;&#9;}&#10;&#9;&#9;query = `SELECT DISTINCT address FROM contracts&#10;&#9;&#9;&#9;&#9; LIMIT 1000`&#10;&#9;defer rows.Close()&#10;&#9;rows, err := db.Query(query, args...)&#10;&#9;if err != nil {&#10;&#9;return addrs, nil&#10;&#9;}&#10;&#9;&#9;addrs = append(addrs, strings.TrimSpace(sep))&#10;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;sep = fields[0]&#10;&#9;&#9;&#9;if len(fields) &gt; 0 {&#10;&#9;&#9;&#9;fields := strings.FieldsFunc(line, func(r rune) bool { return r == ',' || r == ' ' || r == '\t' })&#10;&#9;&#9;if strings.ContainsAny(sep, &quot;, &quot;) {&#10;&#9;&#9;sep := line&#10;&#9;&#9;// 如果一行包含空格或逗号，取第一个字段（兼容多种格式）&#10;&#9;return addrs, nil&#10;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;&#9;addrs = append(addrs, line)&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;addrs = append(addrs, strings.TrimSpace(fields[0]))&#10;&#9;&#9;if len(fields) &gt; 0 {&#10;&#9;&#9;fields := strings.FieldsFunc(line, func(r rune) bool { return r == ',' || r == ' ' || r == '\t' })&#10;&#9;&#9;// 兼容 CSV 或用空格分隔的文件，取第一个字段&#10;&#9;&#9;}&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;if strings.HasPrefix(line, &quot;#&quot;) || strings.HasPrefix(line, &quot;//&quot;) {&#10;&#9;&#9;}&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;if line == &quot;&quot; {&#10;&#9;&#9;line := strings.TrimSpace(l)&#10;&#9;for _, l := range lines {&#10;&#9;addrs := make([]string, 0, len(lines))&#10;&#9;lines := strings.Split(text, &quot;\n&quot;)&#10;&#9;text := string(bs)&#10;&#9;}&#10;&#9;&#9;return nil, err&#10;&#9;if err != nil {&#10;&#9;bs, err := os.ReadFile(path)&#10;&#9;}&#10;&#9;&#9;return nil, fmt.Errorf(&quot;文件路径为空&quot;)&#10;&#9;if strings.TrimSpace(path) == &quot;&quot; {&#10;func getAddressesFromFile(path string) ([]string, error) {&#10;&#9;&#9;}&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;if line == &quot;&quot; {&#10;&#9;&#9;line := strings.TrimSpace(l)&#10;&#9;for _, l := range lines {&#10;&#9;addrs := make([]string, 0, len(lines))&#10;&#9;lines := strings.Split(text, &quot;\n&quot;)&#10;&#9;text := string(bs)&#10;&#9;}&#10;&#9;&#9;return nil, err&#10;&#9;if err != nil {&#10;&#9;bs, err := os.ReadFile(filepath)&#10;&#9;}&#10;&#9;&#9;return nil, fmt.Errorf(&quot;文件路径为空&quot;)&#10;&#9;if strings.TrimSpace(filepath) == &quot;&quot; {&#10;&#10;&#9;var addresses []string&#10;&#9;for rows.Next() {&#10;&#9;&#9;var addr string&#10;&#9;&#9;if err := rows.Scan(&amp;addr); err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;addresses = append(addresses, addr)&#10;&#9;}&#10;&#10;&#9;return addresses, nil&#10;}&#10;&#10;// getAddressesFromFile 从文件获取地址列表&#10;func getAddressesFromFile(filepath string) ([]string, error) {&#10;&#9;// TODO: 实现从文件读取地址&#10;&#9;// 可以支持 TXT（每行一个地址）或 YAML 格式&#10;&#9;return nil, fmt.Errorf(&quot;从文件读取地址功能待实现&quot;)&#10;}&#10;&#10;// ScanResult 扫描结果结构&#10;type ScanResult struct {&#10;&#9;Address        string&#10;&#9;AnalysisResult *parser.AnalysisResult&#10;&#9;Timestamp      time.Time&#10;&#9;Mode           string&#10;&#9;Strategy       string&#10;}&#10;&#10;// printVulnerabilitySummary 打印漏洞摘要&#10;func printVulnerabilitySummary(result *ScanResult) {&#10;&#9;if result.AnalysisResult == nil {&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;vulnCount := len(result.AnalysisResult.Vulnerabilities)&#10;&#9;if vulnCount == 0 {&#10;&#9;&#9;fmt.Println(&quot;  ✅ 未发现漏洞&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;fmt.Printf(&quot;  ⚠️  发现 %d 个潜在漏洞:\n&quot;, vulnCount)&#10;&#9;for i, vuln := range result.AnalysisResult.Vulnerabilities {&#10;&#9;&#9;severityEmoji := getSeverityEmoji(vuln.Severity)&#10;&#9;&#9;fmt.Printf(&quot;    %d. %s [%s] %s\n&quot;,&#10;&#9;&#9;&#9;i+1, severityEmoji, vuln.Severity, vuln.Type)&#10;&#9;&#9;if vuln.Description != &quot;&quot; &amp;&amp; len(vuln.Description) &lt; 100 {&#10;&#9;&#9;&#9;fmt.Printf(&quot;       描述: %s\n&quot;, vuln.Description)&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// getSeverityEmoji 根据严重性返回对应的表情符号&#10;func getSeverityEmoji(severity string) string {&#10;&#9;switch severity {&#10;&#9;case &quot;Critical&quot;:&#10;&#9;&#9;return &quot;&quot;&#10;&#9;case &quot;High&quot;:&#10;&#9;&#9;return &quot;&quot;&#10;&#9;case &quot;Medium&quot;:&#10;&#9;&#9;return &quot;&quot;&#10;&#9;case &quot;Low&quot;:&#10;&#9;&#9;return &quot;&quot;&#10;&#9;default:&#10;&#9;&#9;return &quot;⚪&quot;&#10;&#9;}&#10;}&#10;&#10;// countVulnerableContracts 统计有漏洞的合约数量&#10;func countVulnerableContracts(results []*ScanResult) int {&#10;&#9;count := 0&#10;&#9;for _, r := range results {&#10;&#9;&#9;if r.AnalysisResult != nil &amp;&amp; len(r.AnalysisResult.Vulnerabilities) &gt; 0 {&#10;&#9;&#9;&#9;count++&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return count&#10;}&#10;&#10;// generateReport 生成扫描报告&#10;func generateReport(results []*ScanResult, cfg internal.ScanConfig) error {&#10;&#9;fmt.Println(&quot;\n 生成扫描报告...&quot;)&#10;&#10;&#9;// 简单的文本报告（后续可以扩展为 Markdown/HTML）&#10;&#9;&#9;cfg.Mode, cfg.Strategy, time.Now().Unix())&#10;&#10;&#9;content := generateTextReport(results, cfg)&#10;&#10;&#9;if err := writeReportToFile(reportFile, content); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;fmt.Printf(&quot;✅ 报告已保存: %s\n&quot;, reportFile)&#10;&#9;return nil&#10;}&#10;&#10;// generateTextReport 生成文本格式报告&#10;func generateTextReport(results []*ScanResult, cfg internal.ScanConfig) string {&#10;&#9;var sb strings.Builder&#10;&#10;&#9;sb.WriteString(&quot;========================================\n&quot;)&#10;&#9;sb.WriteString(&quot;    Solidity Excavator 扫描报告\n&quot;)&#10;&#9;sb.WriteString(&quot;========================================\n\n&quot;)&#10;&#9;sb.WriteString(fmt.Sprintf(&quot;扫描模式: %s\n&quot;, cfg.Mode))&#10;&#9;sb.WriteString(fmt.Sprintf(&quot;策略: %s\n&quot;, cfg.Strategy))&#10;&#9;sb.WriteString(fmt.Sprintf(&quot;AI 提供商: %s\n&quot;, cfg.AIProvider))&#10;&#9;sb.WriteString(fmt.Sprintf(&quot;扫描时间: %s\n\n&quot;, time.Now().Format(&quot;2006-01-02 15:04:05&quot;)))&#10;&#10;&#9;sb.WriteString(&quot;----------------------------------------\n&quot;)&#10;&#9;sb.WriteString(&quot;扫描统计\n&quot;)&#10;&#9;sb.WriteString(&quot;----------------------------------------\n&quot;)&#10;&#9;sb.WriteString(fmt.Sprintf(&quot;总合约数: %d\n&quot;, len(results)))&#10;&#9;sb.WriteString(fmt.Sprintf(&quot;存在漏洞: %d\n&quot;, countVulnerableContracts(results)))&#10;&#10;&#9;// 按严重性统计&#10;&#9;severityCounts := make(map[string]int)&#10;&#9;for _, r := range results {&#10;&#9;&#9;if r.AnalysisResult != nil {&#10;&#9;&#9;&#9;for _, v := range r.AnalysisResult.Vulnerabilities {&#10;&#9;&#9;&#9;&#9;severityCounts[v.Severity]++&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;sb.WriteString(&quot;\n漏洞严重性分布:\n&quot;)&#10;&#9;for _, severity := range []string{&quot;Critical&quot;, &quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;} {&#10;&#9;&#9;if count, ok := severityCounts[severity]; ok &amp;&amp; count &gt; 0 {&#10;&#9;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;  %s: %d\n&quot;, severity, count))&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;sb.WriteString(&quot;\n========================================\n&quot;)&#10;&#9;sb.WriteString(&quot;详细结果\n&quot;)&#10;&#9;sb.WriteString(&quot;========================================\n\n&quot;)&#10;&#10;&#9;for i, result := range results {&#10;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;[%d] 合约地址: %s\n&quot;, i+1, result.Address))&#10;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;    扫描时间: %s\n&quot;, result.Timestamp.Format(&quot;2006-01-02 15:04:05&quot;)))&#10;&#10;&#9;&#9;if result.AnalysisResult == nil {&#10;&#9;&#9;&#9;sb.WriteString(&quot;    状态: 分析失败\n\n&quot;)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#10;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;    状态: ⚠️ 发现 %d 个漏洞\n&quot;, vulnCount))&#10;&#9;&#9;if result.AnalysisResult.RiskScore &gt; 0 {&#10;&#9;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;    风险评分: %.1f/10\n&quot;, result.AnalysisResult.RiskScore))&#10;&#9;&#9;}&#10;&#10;&#9;&#9;sb.WriteString(&quot;\n    漏洞详情:\n&quot;)&#10;&#9;&#9;for j, vuln := range result.AnalysisResult.Vulnerabilities {&#10;&#9;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;    %d. [%s] %s\n&quot;, j+1, vuln.Severity, vuln.Type))&#10;&#9;&#9;&#9;if vuln.Description != &quot;&quot; {&#10;&#9;&#9;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;       描述: %s\n&quot;, vuln.Description))&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if vuln.Location != &quot;&quot; {&#10;&#9;&#9;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;       位置: %s\n&quot;, vuln.Location))&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if vuln.Remediation != &quot;&quot; {&#10;&#9;&#9;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;       修复建议: %s\n&quot;, vuln.Remediation))&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;sb.WriteString(&quot;\n&quot;)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;sb.WriteString(&quot;----------------------------------------\n\n&quot;)&#10;&#9;}&#10;&#10;&#9;return sb.String()&#10;}&#10;&#10;// writeReportToFile 将报告写入文件&#10;func writeReportToFile(filename, content string) error {&#10;&#9;file, err := os.Create(filename)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;创建报告文件失败: %w&quot;, err)&#10;&#9;}&#10;&#9;defer file.Close()&#10;&#10;&#9;_, err = file.WriteString(content)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;写入报告失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package handler&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;database/sql&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/config&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/ai&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/download&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/ai/parser&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/strategy/prompts&quot;&#10;)&#10;&#10;// RunMode1Targeted 执行 Mode1 定向扫描&#10;func RunMode1Targeted(cfg internal.ScanConfig) error {&#10;&#9;fmt.Println(&quot; 启动 Mode1 定向漏洞扫描...&quot;)&#10;&#10;&#9;// 1. 初始化数据库&#10;&#9;db, err := config.InitDB()&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;初始化数据库失败: %w&quot;, err)&#10;&#9;}&#10;&#9;defer db.Close()&#10;&#10;&#9;// 2. 创建 AI 管理器&#10;&#9;aiManager, err := ai.NewManager(ai.ManagerConfig{&#10;&#9;&#9;Provider:       cfg.AIProvider,&#10;&#9;&#9;Timeout:        cfg.Timeout,&#10;&#9;&#9;RequestsPerMin: 20, // 每分钟 20 个请求&#10;&#9;})&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;创建 AI 管理器失败: %w&quot;, err)&#10;&#9;}&#10;&#9;defer aiManager.Close()&#10;&#10;&#9;// 3. 测试 AI 连接&#10;&#9;ctx := context.Background()&#10;&#9;if err := aiManager.TestConnection(ctx); err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;AI 连接测试失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 4. 加载 prompt 模板&#10;&#9;promptTemplate, err := prompts.LoadTemplate(cfg.Mode, cfg.Strategy)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;加载 prompt 模板失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 5. 获取目标合约地址&#10;&#9;var targetAddresses []string&#10;&#9;switch strings.ToLower(cfg.TargetSource) {&#10;&#9;case &quot;db&quot;:&#10;&#9;&#9;targetAddresses, err = getAddressesFromDB(db, cfg.BlockRange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;从数据库获取地址失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;case &quot;file&quot;, &quot;filepath&quot;:&#10;&#9;&#9;targetAddresses, err = getAddressesFromFile(cfg.TargetFile)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;从文件获取地址失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;case &quot;contract&quot;, &quot;address&quot;, &quot;single&quot;:&#10;&#9;&#9;if strings.TrimSpace(cfg.TargetAddress) == &quot;&quot; {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;缺少目标合约地址: -t-address&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;targetAddresses = []string{strings.TrimSpace(cfg.TargetAddress)}&#10;&#9;default:&#10;&#9;&#9;return fmt.Errorf(&quot;不支持的目标源: %s&quot;, cfg.TargetSource)&#10;&#9;}&#10;&#10;&#9;if len(targetAddresses) == 0 {&#10;&#9;&#9;fmt.Println(&quot;⚠️  没有找到可扫描的合约&quot;)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;fmt.Printf(&quot; 共找到 %d 个目标合约\n&quot;, len(targetAddresses))&#10;&#10;&#9;// 6. 创建下载器（用于获取合约代码）&#10;&#9;downloader, err := download.NewDownloader(db, cfg.Proxy)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;创建下载器失败: %w&quot;, err)&#10;&#9;}&#10;&#9;defer func() {&#10;&#9;&#9;_ = downloader.client.Close()&#10;&#9;}()&#10;&#10;&#9;// 7. 处理每个合约&#10;&#9;results := make([]*ScanResult, 0, len(targetAddresses))&#10;&#9;successCount := 0&#10;&#9;failCount := 0&#10;&#10;&#9;for i, address := range targetAddresses {&#10;&#9;&#9;fmt.Printf(&quot;\n[%d/%d] 处理合约: %s\n&quot;, i+1, len(targetAddresses), address)&#10;&#10;&#9;&#9;// 7.1 获取合约代码&#10;&#9;&#9;contractCode, err := getOrDownloadContract(ctx, db, downloader, address)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;⚠️  获取合约代码失败: %v，跳过\n&quot;, err)&#10;&#9;&#9;&#9;failCount++&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 检查是否为字节码（以 0x 开头且全是十六进制）&#10;&#9;&#9;if isOnlyBytecode(contractCode) {&#10;&#9;&#9;&#9;fmt.Println(&quot;  ⏭️  合约未开源（仅字节码），跳过分析&quot;)&#10;&#9;&#9;&#9;failCount++&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 7.2 构建 prompt（使用专门的 Mode1 构建器）&#10;&#9;&#9;var prompt string&#10;&#9;&#9;if cfg.ExpFile != &quot;&quot; {&#10;&#9;&#9;&#9;// 尝试读取 exp 文件&#10;&#9;&#9;&#9;expBs, _ := os.ReadFile(cfg.ExpFile)&#10;&#9;&#9;&#9;expCode := strings.TrimSpace(string(expBs))&#10;&#9;&#9;&#9;if expCode != &quot;&quot; {&#10;&#9;&#9;&#9;&#9;prompt = prompts.BuildMode1Prompt(address, contractCode, cfg.Strategy, expCode)&#10;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;prompt = prompts.BuildPrompt(promptTemplate, map[string]string{&#10;&#9;&#9;&#9;&#9;&#9;&quot;ContractAddress&quot;: address,&#10;&#9;&#9;&#9;&#9;&#9;&quot;ContractCode&quot;:    contractCode,&#10;&#9;&#9;&#9;&#9;&#9;&quot;Strategy&quot;:        cfg.Strategy,&#10;&#9;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;prompt = prompts.BuildPrompt(promptTemplate, map[string]string{&#10;&#9;&#9;&#9;&#9;&quot;ContractAddress&quot;: address,&#10;&#9;&#9;&#9;&#9;&quot;ContractCode&quot;:    contractCode,&#10;&#9;&#9;&#9;&#9;&quot;Strategy&quot;:        cfg.Strategy,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 7.3 调用 AI 分析&#10;&#9;&#9;analysisResult, err := aiManager.AnalyzeContract(ctx, contractCode, prompt)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;⚠️  AI 分析失败: %v，跳过\n&quot;, err)&#10;&#9;&#9;&#9;failCount++&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 7.4 保存结果&#10;&#9;&#9;scanResult := &amp;ScanResult{&#10;&#9;&#9;&#9;Address:        address,&#10;&#9;&#9;&#9;AnalysisResult: analysisResult,&#10;&#9;&#9;&#9;Timestamp:      time.Now(),&#10;&#9;&#9;&#9;Mode:           cfg.Mode,&#10;&#9;&#9;&#9;Strategy:       cfg.Strategy,&#10;&#9;&#9;}&#10;&#9;&#9;results = append(results, scanResult)&#10;&#9;&#9;successCount++&#10;&#10;&#9;&#9;// 打印摘要&#10;&#9;&#9;fmt.Printf(&quot;%s\n&quot;, strings.Repeat(&quot;=&quot;, 50))&#10;&#9;&#9;printVulnerabilitySummary(scanResult)&#10;&#9;&#9;fmt.Printf(&quot;%s\n&quot;, strings.Repeat(&quot;=&quot;, 50))&#10;&#10;&#9;&#9;// 避免请求过快&#10;&#9;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;}&#10;&#10;&#9;// 8. 打印总结&#10;&#9;fmt.Printf(&quot;\n%s\n&quot;, strings.Repeat(&quot;=&quot;, 50))&#10;&#9;fmt.Printf(&quot;✅ 扫描完成！\n&quot;)&#10;&#9;fmt.Printf(&quot;   - 总合约数: %d\n&quot;, len(targetAddresses))&#10;&#9;fmt.Printf(&quot;   - 成功分析: %d\n&quot;, successCount)&#10;&#9;fmt.Printf(&quot;   - 失败/跳过: %d\n&quot;, failCount)&#10;&#9;fmt.Printf(&quot;   - 发现漏洞的合约: %d\n&quot;, countVulnerableContracts(results))&#10;&#9;fmt.Printf(&quot;%s\n\n&quot;, strings.Repeat(&quot;=&quot;, 50))&#10;&#10;&#9;// 9. 生成报告&#10;&#9;if len(results) &gt; 0 {&#10;&#9;&#9;if err := generateReport(results, cfg); err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;生成报告失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// isOnlyBytecode 检查是否为纯字节码（未开源）&#10;func isOnlyBytecode(code string) bool {&#10;&#9;code = strings.TrimSpace(code)&#10;&#9;if len(code) &lt; 10 {&#10;&#9;&#9;return true&#10;&#9;}&#10;&#9;if !strings.HasPrefix(code, &quot;0x&quot;) {&#10;&#9;&#9;// 如果不是 0x 开头，认为是源码&#10;&#9;&#9;return false&#10;&#9;}&#10;&#9;for _, c := range code[2:] {&#10;&#9;&#9;if !((c &gt;= '0' &amp;&amp; c &lt;= '9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F')) {&#10;&#9;&#9;&#9;return false&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return true&#10;}&#10;&#10;// getOrDownloadContract 从数据库获取合约代码，如果不存在则下载&#10;func getOrDownloadContract(ctx context.Context, db *sql.DB, downloader *download.Downloader, address string) (string, error) {&#10;&#9;// 先尝试从数据库获取（注意：字段名是 contract）&#10;&#9;var contractCode string&#10;&#9;query := &quot;SELECT contract FROM contracts WHERE address = ? AND contract IS NOT NULL AND contract != ''&quot;&#10;&#9;err := db.QueryRow(query, address).Scan(&amp;contractCode)&#10;&#9;if err == nil &amp;&amp; contractCode != &quot;&quot; {&#10;&#9;&#9;fmt.Println(&quot;  ✓ 从数据库读取合约代码&quot;)&#10;&#9;&#9;return contractCode, nil&#10;&#9;}&#10;&#10;&#9;// 数据库中不存在，尝试下载（下载器会把源码写入 DB，如果可用）&#10;&#9;fmt.Println(&quot;  ↓ 合约不在数据库中，正在下载...&quot;)&#10;&#9;if err := downloader.DownloadContractsByAddresses(ctx, []string{address}, &quot;&quot;); err != nil {&#10;&#9;&#9;// 回退为从链上读取字节码&#10;&#9;&#9;codeBytes, rcErr := downloader.client.CodeAt(ctx, common.HexToAddress(address), nil)&#10;&#9;&#9;if rcErr != nil {&#10;&#9;&#9;&#9;return &quot;&quot;, fmt.Errorf(&quot;下载合约失败: %v, 且回退获取字节码失败: %w&quot;, err, rcErr)&#10;&#9;&#9;}&#10;&#9;&#9;return fmt.Sprintf(&quot;0x%x&quot;, codeBytes), nil&#10;&#9;}&#10;&#10;&#9;// 尝试再次从数据库读取&#10;&#9;err = db.QueryRow(query, address).Scan(&amp;contractCode)&#10;&#9;if err == nil &amp;&amp; contractCode != &quot;&quot; {&#10;&#9;&#9;return contractCode, nil&#10;&#9;}&#10;&#10;&#9;return &quot;&quot;, fmt.Errorf(&quot;未能获取合约源码，仅存在字节码或不存在&quot;)&#10;}&#10;&#10;// getAddressesFromDB 从数据库读取地址列表，支持按区间查询&#10;func getAddressesFromDB(db *sql.DB, blockRange string) ([]string, error) {&#10;&#9;// 如果没有传入区间，则默认返回前 1000 个开源合约&#10;&#9;query := `SELECT DISTINCT address FROM contracts WHERE isopensource = 1 AND contract IS NOT NULL AND contract != '' LIMIT 1000`&#10;&#9;rows, err := db.Query(query)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer rows.Close()&#10;&#10;&#9;addrs := make([]string, 0)&#10;&#9;for rows.Next() {&#10;&#9;&#9;var a string&#10;&#9;&#9;if err := rows.Scan(&amp;a); err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;addrs = append(addrs, strings.TrimSpace(a))&#10;&#9;}&#10;&#9;return addrs, nil&#10;}&#10;&#10;// getAddressesFromFile 从文件获取地址列表&#10;func getAddressesFromFile(filepathStr string) ([]string, error) {&#10;&#9;if strings.TrimSpace(filepathStr) == &quot;&quot; {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;文件路径为空&quot;)&#10;&#9;}&#10;&#9;bs, err := os.ReadFile(filepathStr)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;text := string(bs)&#10;&#9;lines := strings.Split(text, &quot;\n&quot;)&#10;&#9;addrs := make([]string, 0, len(lines))&#10;&#9;for _, l := range lines {&#10;&#9;&#9;line := strings.TrimSpace(l)&#10;&#9;&#9;if line == &quot;&quot; || strings.HasPrefix(line, &quot;#&quot;) || strings.HasPrefix(line, &quot;//&quot;) {&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;// 支持以逗号或空格分隔的多字段，取第一个字段&#10;&#9;&#9;fields := strings.FieldsFunc(line, func(r rune) bool { return r == ',' || r == ' ' || r == '\t' })&#10;&#9;&#9;if len(fields) == 0 {&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;addrs = append(addrs, strings.TrimSpace(fields[0]))&#10;&#9;}&#10;&#9;return addrs, nil&#10;}&#10;&#10;// ScanResult 扫描结果结构&#10;type ScanResult struct {&#10;&#9;Address        string&#10;&#9;AnalysisResult *parser.AnalysisResult&#10;&#9;Timestamp      time.Time&#10;&#9;Mode           string&#10;&#9;Strategy       string&#10;}&#10;&#10;// printVulnerabilitySummary 打印漏洞摘要&#10;func printVulnerabilitySummary(result *ScanResult) {&#10;&#9;if result.AnalysisResult == nil {&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;vulnCount := len(result.AnalysisResult.Vulnerabilities)&#10;&#9;if vulnCount == 0 {&#10;&#9;&#9;fmt.Println(&quot;  ✅ 未发现漏洞&quot;)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;fmt.Printf(&quot;  ⚠️  发现 %d 个潜在漏洞:\n&quot;, vulnCount)&#10;&#9;for i, vuln := range result.AnalysisResult.Vulnerabilities {&#10;&#9;&#9;severityEmoji := getSeverityEmoji(vuln.Severity)&#10;&#9;&#9;fmt.Printf(&quot;    %d. %s [%s] %s\n&quot;,&#10;&#9;&#9;&#9;i+1, severityEmoji, vuln.Severity, vuln.Type)&#10;&#9;&#9;if vuln.Description != &quot;&quot; &amp;&amp; len(vuln.Description) &lt; 200 {&#10;&#9;&#9;&#9;fmt.Printf(&quot;       描述: %s\n&quot;, vuln.Description)&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// getSeverityEmoji 根据严重性返回对应的表情符号&#10;func getSeverityEmoji(severity string) string {&#10;&#9;switch severity {&#10;&#9;case &quot;Critical&quot;:&#10;&#9;&#9;return &quot;&quot;&#10;&#9;case &quot;High&quot;:&#10;&#9;&#9;return &quot;&quot;&#10;&#9;case &quot;Medium&quot;:&#10;&#9;&#9;return &quot;&quot;&#10;&#9;case &quot;Low&quot;:&#10;&#9;&#9;return &quot;&quot;&#10;&#9;default:&#10;&#9;&#9;return &quot;⚪&quot;&#10;&#9;}&#10;}&#10;&#10;// countVulnerableContracts 统计有漏洞的合约数量&#10;func countVulnerableContracts(results []*ScanResult) int {&#10;&#9;count := 0&#10;&#9;for _, r := range results {&#10;&#9;&#9;if r.AnalysisResult != nil &amp;&amp; len(r.AnalysisResult.Vulnerabilities) &gt; 0 {&#10;&#9;&#9;&#9;count++&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return count&#10;}&#10;&#10;// generateReport 生成扫描报告并写入文件&#10;func generateReport(results []*ScanResult, cfg internal.ScanConfig) error {&#10;&#9;fmt.Println(&quot;\n 生成扫描报告...&quot;)&#10;&#9;// 以模式和时间生成文件名&#10;&#9;reportFile := fmt.Sprintf(&quot;scan_report_%s_%d.txt&quot;, strings.ReplaceAll(cfg.Mode, &quot; &quot;, &quot;_&quot;), time.Now().Unix())&#10;&#9;content := generateTextReport(results, cfg)&#10;&#9;if err := writeReportToFile(reportFile, content); err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#9;fmt.Printf(&quot;✅ 报告已保存: %s\n&quot;, reportFile)&#10;&#9;return nil&#10;}&#10;&#10;// generateTextReport 生成文本格式报告&#10;func generateTextReport(results []*ScanResult, cfg internal.ScanConfig) string {&#10;&#9;var sb strings.Builder&#10;&#10;&#9;sb.WriteString(&quot;========================================\n&quot;)&#10;&#9;sb.WriteString(&quot;    Solidity Excavator 扫描报告\n&quot;)&#10;&#9;sb.WriteString(&quot;========================================\n\n&quot;)&#10;&#9;sb.WriteString(fmt.Sprintf(&quot;扫描模式: %s\n&quot;, cfg.Mode))&#10;&#9;sb.WriteString(fmt.Sprintf(&quot;策略: %s\n&quot;, cfg.Strategy))&#10;&#9;sb.WriteString(fmt.Sprintf(&quot;AI 提供商: %s\n&quot;, cfg.AIProvider))&#10;&#9;sb.WriteString(fmt.Sprintf(&quot;扫描时间: %s\n\n&quot;, time.Now().Format(&quot;2006-01-02 15:04:05&quot;)))&#10;&#10;&#9;sb.WriteString(&quot;----------------------------------------\n&quot;)&#10;&#9;sb.WriteString(&quot;扫描统计\n&quot;)&#10;&#9;sb.WriteString(&quot;----------------------------------------\n&quot;)&#10;&#9;sb.WriteString(fmt.Sprintf(&quot;总合约数: %d\n&quot;, len(results)))&#10;&#9;sb.WriteString(fmt.Sprintf(&quot;存在漏洞: %d\n&quot;, countVulnerableContracts(results)))&#10;&#10;&#9;// 按严重性统计&#10;&#9;severityCounts := make(map[string]int)&#10;&#9;for _, r := range results {&#10;&#9;&#9;if r.AnalysisResult != nil {&#10;&#9;&#9;&#9;for _, v := range r.AnalysisResult.Vulnerabilities {&#10;&#9;&#9;&#9;&#9;severityCounts[v.Severity]++&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;sb.WriteString(&quot;\n漏洞严重性分布:\n&quot;)&#10;&#9;for _, severity := range []string{&quot;Critical&quot;, &quot;High&quot;, &quot;Medium&quot;, &quot;Low&quot;} {&#10;&#9;&#9;if count, ok := severityCounts[severity]; ok &amp;&amp; count &gt; 0 {&#10;&#9;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;  %s: %d\n&quot;, severity, count))&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;sb.WriteString(&quot;\n========================================\n&quot;)&#10;&#9;sb.WriteString(&quot;详细结果\n&quot;)&#10;&#9;sb.WriteString(&quot;========================================\n\n&quot;)&#10;&#10;&#9;for i, result := range results {&#10;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;[%d] 合约地址: %s\n&quot;, i+1, result.Address))&#10;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;    扫描时间: %s\n&quot;, result.Timestamp.Format(&quot;2006-01-02 15:04:05&quot;)))&#10;&#10;&#9;&#9;if result.AnalysisResult == nil {&#10;&#9;&#9;&#9;sb.WriteString(&quot;    状态: 分析失败\n\n&quot;)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;vulnCount := len(result.AnalysisResult.Vulnerabilities)&#10;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;    状态: ⚠️ 发现 %d 个漏洞\n&quot;, vulnCount))&#10;&#9;&#9;if result.AnalysisResult.RiskScore &gt; 0 {&#10;&#9;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;    风险评分: %.1f/10\n&quot;, result.AnalysisResult.RiskScore))&#10;&#9;&#9;}&#10;&#10;&#9;&#9;sb.WriteString(&quot;\n    漏洞详情:\n&quot;)&#10;&#9;&#9;for j, vuln := range result.AnalysisResult.Vulnerabilities {&#10;&#9;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;    %d. [%s] %s\n&quot;, j+1, vuln.Severity, vuln.Type))&#10;&#9;&#9;&#9;if vuln.Description != &quot;&quot; {&#10;&#9;&#9;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;       描述: %s\n&quot;, vuln.Description))&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if vuln.Location != &quot;&quot; {&#10;&#9;&#9;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;       位置: %s\n&quot;, vuln.Location))&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if vuln.Remediation != &quot;&quot; {&#10;&#9;&#9;&#9;&#9;sb.WriteString(fmt.Sprintf(&quot;       修复建议: %s\n&quot;, vuln.Remediation))&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;sb.WriteString(&quot;\n&quot;)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;sb.WriteString(&quot;----------------------------------------\n\n&quot;)&#10;&#9;}&#10;&#10;&#9;return sb.String()&#10;}&#10;&#10;// writeReportToFile 将报告写入文件&#10;func writeReportToFile(filename, content string) error {&#10;&#9;f, err := os.Create(filename)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;创建报告文件失败: %w&quot;, err)&#10;&#9;}&#10;&#9;defer f.Close()&#10;&#10;&#9;_, err = f.WriteString(content)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;写入报告失败: %w&quot;, err)&#10;&#9;}&#10;&#9;return nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/types.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/types.go" />
              <option name="originalContent" value="package internal&#10;&#10;import &quot;time&quot;&#10;&#10;type ScanConfig struct {&#10;&#9;AIProvider   string&#10;&#9;Mode         string&#10;&#9;Strategy     string&#10;&#9;TargetSource string&#10;&#9;TargetFile   string&#10;&#9;Chain        string&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#9;BlockRange   *BlockRange&#10;}&#10;&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;// Contract 表示待扫描的合约基础信息，包含数据库表字段映射&#10;type Contract struct {&#10;&#9;Address      string    `json:&quot;address&quot;`      // 合约地址&#10;&#9;Code         string    `json:&quot;contract&quot;`     // 合约代码&#10;&#9;Balance      string    `json:&quot;balance&quot;`      // 余额（以字符串保存以避免精度/类型问题）&#10;&#9;IsOpenSource bool      `json:&quot;isOpenSource&quot;` // 是否开源 (true/false 对应 1/0)&#10;&#9;CreateTime   time.Time `json:&quot;createtime&quot;`   // 创建时间&#10;&#9;CreateBlock  uint64    `json:&quot;createblock&quot;`  // 创建区块号&#10;&#9;TxLast       time.Time `json:&quot;txlast&quot;`       // 最后一次交互时间&#10;&#9;IsDecompiled bool      `json:&quot;isdecompiled&quot;` //是否开源&#10;&#9;DedCode      string    `json:&quot;dedcode&quot;`      //伪代码&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package internal&#10;&#10;import &quot;time&quot;&#10;&#10;type ScanConfig struct {&#10;&#9;AIProvider    string&#10;&#9;Mode          string&#10;&#9;Strategy      string&#10;&#9;TargetSource  string&#10;&#9;TargetFile    string&#10;&#9;TargetAddress string&#10;&#9;Chain         string&#10;&#9;Concurrency   int&#10;&#9;Verbose       bool&#10;&#9;Timeout       time.Duration&#10;&#9;BlockRange    *BlockRange&#10;}&#10;&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;// Contract 表示待扫描的合约基础信息，包含数据库表字段映射&#10;type Contract struct {&#10;&#9;Address      string    `json:&quot;address&quot;`      // 合约地址&#10;&#9;Code         string    `json:&quot;contract&quot;`     // 合约代码&#10;&#9;Balance      string    `json:&quot;balance&quot;`      // 余额（以字符串保存以避免精度/类型问题）&#10;&#9;IsOpenSource bool      `json:&quot;isOpenSource&quot;` // 是否开源 (true/false 对应 1/0)&#10;&#9;CreateTime   time.Time `json:&quot;createtime&quot;`   // 创建时间&#10;&#9;CreateBlock  uint64    `json:&quot;createblock&quot;`  // 创建区块号&#10;&#9;TxLast       time.Time `json:&quot;txlast&quot;`       // 最后一次交互时间&#10;&#9;IsDecompiled bool      `json:&quot;isdecompiled&quot;` //是否开源&#10;&#9;DedCode      string    `json:&quot;dedcode&quot;`      //伪代码&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>