<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/cmd/cli.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/cmd/cli.go" />
              <option name="originalContent" value="package cmd&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;flag&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/config&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/download&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/handler&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// Reporter 先不写&#10;&#10;// CLIConfig 保存解析好的 CLI 选项以及供扫描器使用的规范化字&#10;// 段。&#10;type CLIConfig struct {&#10;&#9;AIProvider   string // 例如 chatgpt5&#10;&#9;Mode         string // mode1 | mode2 | mode3&#10;&#9;Strategy     string // 例如 hourglass-vul 或 &quot;all&quot;&#10;&#9;TargetSource string // &quot;db&quot; 或 &quot;file&quot; - 从哪里获取目标列表&#10;&#9;BlockRange   *BlockRange&#10;&#9;TargetFile   string // 包含地址/批次的 YAML 路径&#10;&#9;Chain        string // eth | bsc | arb&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#10;&#9;// Reporter 相关配置&#10;&#9;//ReportEnabled bool     // 是否生成报告&#10;&#9;//ReportFormats []string // 支持的格式：md,json,html,pdf&#10;&#9;//ReportOut     string   // 报告输出目录或前缀&#10;&#10;&#9;// 下载相关配置&#10;&#9;Download bool   // -d 启动下载流程&#10;&#9;RPCURL   string // -rpc 以太坊节点 RPC URL&#10;&#9;//DBDSN         string      // -dbdsn 可选的数据库 DSN，优先于环境变量 DATABASE_URL&#10;&#9;DownloadRange *BlockRange // -d-range 指定下载区块范围（格式 start-end），为空表示从上次继续下载&#10;}&#10;&#10;// BlockRange 简单的起止区块范围结构&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;func (b *BlockRange) String() string {&#10;&#9;if b == nil {&#10;&#9;&#9;return &quot;&quot;&#10;&#9;}&#10;&#9;return fmt.Sprintf(&quot;%d-%d&quot;, b.Start, b.End)&#10;}&#10;&#10;// parseBlockRange 解析类似 &quot;1-220234&quot; 或 &quot;1000-&quot;（开放结束）的字符串并返回 BlockRange。&#10;func parseBlockRange(s string) (*BlockRange, error) {&#10;&#9;if strings.TrimSpace(s) == &quot;&quot; {&#10;&#9;&#9;return nil, nil&#10;&#9;}&#10;&#9;parts := strings.Split(s, &quot;-&quot;)&#10;&#9;if len(parts) != 2 {&#10;&#9;&#9;return nil, errors.New(&quot;invalid block range format, expected start-end&quot;)&#10;&#9;}&#10;&#9;startStr := strings.TrimSpace(parts[0])&#10;&#9;endStr := strings.TrimSpace(parts[1])&#10;&#9;var br BlockRange&#10;&#9;if startStr == &quot;&quot; {&#10;&#9;&#9;return nil, errors.New(&quot;start block required&quot;)&#10;&#9;}&#10;&#9;start, err := strconv.ParseUint(startStr, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid start block: %w&quot;, err)&#10;&#9;}&#10;&#9;br.Start = start&#10;&#9;if endStr == &quot;&quot; {&#10;&#9;&#9;br.End = ^uint64(0) // max uint64 to indicate open-ended&#10;&#9;} else {&#10;&#9;&#9;end, err := strconv.ParseUint(endStr, 10, 64)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;invalid end block: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if end &lt; start {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;end block must be &gt;= start block&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;br.End = end&#10;&#9;}&#10;&#9;return &amp;br, nil&#10;}&#10;&#10;// Validate 检查 CLIConfig 的必需/一致性输入。&#10;func (c *CLIConfig) Validate() error {&#10;&#9;if c.AIProvider == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-ai is required (e.g. -ai chatgpt5)&quot;)&#10;&#9;}&#10;&#9;if c.Mode == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-m (mode) is required: mode1|mode2|mode3&quot;)&#10;&#9;}&#10;&#9;if c.Mode != &quot;mode1&quot; &amp;&amp; c.Mode != &quot;mode2&quot; &amp;&amp; c.Mode != &quot;mode3&quot; {&#10;&#9;&#9;return errors.New(&quot;-m must be one of: mode1, mode2, mode3&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource != &quot;db&quot; &amp;&amp; c.TargetSource != &quot;file&quot; {&#10;&#9;&#9;return errors.New(&quot;-t must be either 'db' or 'file'&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource == &quot;file&quot; &amp;&amp; c.TargetFile == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-t-file is required when -t=file&quot;)&#10;&#9;}&#10;&#9;if c.Chain == &quot;&quot; {&#10;&#9;&#9;c.Chain = &quot;eth&quot; // default&#10;&#9;}&#10;&#9;if c.Concurrency &lt;= 0 {&#10;&#9;&#9;c.Concurrency = 4&#10;&#9;}&#10;&#10;&#9;// Validate report formats if reporting enabled&#10;&#9;//if c.ReportEnabled {&#10;&#9;//&#9;if c.ReportOut == &quot;&quot; {&#10;&#9;//&#9;&#9;return errors.New(&quot;-report-out is required when -report is enabled&quot;)&#10;&#9;//&#9;}&#10;&#9;//&#9;allowed := map[string]bool{&quot;md&quot;: true, &quot;json&quot;: true, &quot;html&quot;: true, &quot;pdf&quot;: true}&#10;&#9;//&#9;for _, f := range c.ReportFormats {&#10;&#9;//&#9;&#9;if !allowed[strings.ToLower(f)] {&#10;&#9;//&#9;&#9;&#9;return fmt.Errorf(&quot;unsupported report format: %s&quot;, f)&#10;&#9;//&#9;&#9;}&#10;&#9;//&#9;}&#10;&#9;//}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// ParseFlags 解析 os.Args 并返回 CLIConfig 或错误。用于从 main 调用。&#10;func ParseFlags() (*CLIConfig, error) {&#10;&#9;fs := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)&#10;&#9;fs.Usage = func() {&#10;&#9;&#9;w := fs.Output()&#10;&#9;&#9;fmt.Fprintln(w, &quot;用法: excavator -ai &lt;provider&gt; -m &lt;mode&gt; [选项]&quot;)&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;选项:&quot;)&#10;&#9;&#9;fs.PrintDefaults()&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;示例:&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s hourglass-vul -t file -t-file ./data/source_contracts/sample.yaml -c eth&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s all -t db -t-block 1-220234 -c eth&quot;)&#10;&#9;}&#10;&#10;&#9;// 新增下载相关 flags&#10;&#9;downloadFlag := fs.Bool(&quot;d&quot;, false, &quot;启动区块/合约下载流程（从数据库记录的最后区块继续，或使用 -d-range 指定范围）&quot;)&#10;&#9;rpc := fs.String(&quot;rpc&quot;, &quot;&quot;, &quot;以太坊节点 RPC URL（当使用 -d 时通常需要）&quot;)&#10;&#9;//dbdsn := fs.String(&quot;dbdsn&quot;, &quot;&quot;, &quot;Postgres DSN（可选），若不提供将使用环境变量 DATABASE_URL&quot;)&#10;&#9;drange := fs.String(&quot;d-range&quot;, &quot;&quot;, &quot;下载区块范围（format start-end），与 -d 一起使用时覆盖从上次继续的行为&quot;)&#10;&#10;&#9;ai := fs.String(&quot;ai&quot;, &quot;&quot;, &quot;AI provider to use (e.g. chatgpt5)&quot;)&#10;&#9;mode := fs.String(&quot;m&quot;, &quot;&quot;, &quot;Mode to run: mode1(targeted) | mode2(fuzzy) | mode3(general)&quot;)&#10;&#9;strategy := fs.String(&quot;s&quot;, &quot;all&quot;, &quot;Strategy/prompt name in strategy/prompts/&lt;mode&gt;/ (or 'all')&quot;)&#10;&#9;target := fs.String(&quot;t&quot;, &quot;db&quot;, &quot;Target source: 'db' or 'file' (default db)&quot;)&#10;&#9;blockRange := fs.String(&quot;t-block&quot;, &quot;&quot;, &quot;Block range for scanning (format start-end, e.g. 1-220234)&quot;)&#10;&#9;tfile := fs.String(&quot;t-file&quot;, &quot;&quot;, &quot;YAML file path when -t=file; can be a directory for batching&quot;)&#10;&#9;chain := fs.String(&quot;c&quot;, &quot;eth&quot;, &quot;Chain to scan: eth | bsc | arb (default eth)&quot;)&#10;&#9;concurrency := fs.Int(&quot;concurrency&quot;, 4, &quot;Worker concurrency&quot;)&#10;&#9;verbose := fs.Bool(&quot;v&quot;, false, &quot;Verbose output&quot;)&#10;&#9;timeout := fs.Duration(&quot;timeout&quot;, 30*time.Second, &quot;Per-AI request timeout&quot;)&#10;&#9;//report := fs.Bool(&quot;report&quot;, false, &quot;Whether to generate report files after scan (default false)&quot;)&#10;&#9;//reportFormats := fs.String(&quot;report-formats&quot;, &quot;md,json&quot;, &quot;Comma-separated output formats: md,json,html,pdf&quot;)&#10;&#9;//reportOut := fs.String(&quot;report-out&quot;, &quot;./reports&quot;, &quot;Output directory or storage prefix for reports&quot;)&#10;&#10;&#9;if err := fs.Parse(os.Args[1:]); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;cfg := &amp;CLIConfig{&#10;&#9;&#9;AIProvider:   strings.TrimSpace(*ai),&#10;&#9;&#9;Mode:         strings.TrimSpace(*mode),&#10;&#9;&#9;Strategy:     strings.TrimSpace(*strategy),&#10;&#9;&#9;TargetSource: strings.TrimSpace(*target),&#10;&#9;&#9;TargetFile:   strings.TrimSpace(*tfile),&#10;&#9;&#9;Chain:        strings.TrimSpace(*chain),&#10;&#9;&#9;Concurrency:  *concurrency,&#10;&#9;&#9;Verbose:      *verbose,&#10;&#9;&#9;Timeout:      *timeout,&#10;&#9;&#9;//ReportEnabled: *report,&#10;&#9;&#9;//ReportOut:     strings.TrimSpace(*reportOut),&#10;&#9;&#9;Download: *downloadFlag,&#10;&#9;&#9;RPCURL:   strings.TrimSpace(*rpc),&#10;&#9;&#9;//DBDSN:    strings.TrimSpace(*dbdsn),&#10;&#9;}&#10;&#10;&#9;// 解析下载区块范围（如果提供）&#10;&#9;if strings.TrimSpace(*drange) != &quot;&quot; {&#10;&#9;&#9;br, err := parseBlockRange(*drange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;cfg.DownloadRange = br&#10;&#9;}&#10;&#10;&#9;// parse report formats&#10;&#9;//if strings.TrimSpace(*reportFormats) != &quot;&quot; {&#10;&#9;//&#9;parts := strings.Split(*reportFormats, &quot;,&quot;)&#10;&#9;//&#9;for i := range parts {&#10;&#9;//&#9;&#9;parts[i] = strings.ToLower(strings.TrimSpace(parts[i]))&#10;&#9;//&#9;}&#10;&#9;//&#9;cfg.ReportFormats = parts&#10;&#9;//}&#10;&#10;&#9;if strings.TrimSpace(*blockRange) != &quot;&quot; {&#10;&#9;&#9;br, err := parseBlockRange(*blockRange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;cfg.BlockRange = br&#10;&#9;}&#10;&#10;&#9;// normalize target source&#10;&#9;cfg.TargetSource = strings.ToLower(cfg.TargetSource)&#10;&#9;if cfg.TargetSource == &quot;yaml&quot; {&#10;&#9;&#9;cfg.TargetSource = &quot;file&quot; // accept yaml alias&#10;&#9;}&#10;&#10;&#9;// 如果提供了文件路径但不是绝对路径，则将其转为相对于当前工作目录&#10;&#9;if cfg.TargetFile != &quot;&quot; {&#10;&#9;&#9;if !filepath.IsAbs(cfg.TargetFile) {&#10;&#9;&#9;&#9;cwd, _ := os.Getwd()&#10;&#9;&#9;&#9;cfg.TargetFile = filepath.Join(cwd, cfg.TargetFile)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// normalize report-out to absolute path if local&#10;&#9;//cfg.ReportEnabled = *report&#10;&#9;//if cfg.ReportEnabled {&#10;&#9;//&#9;cfg.ReportOut = strings.TrimSpace(*reportOut)&#10;&#9;//&#9;parts := strings.Split(*reportFormats, &quot;,&quot;)&#10;&#9;//&#9;for i := range parts {&#10;&#9;//&#9;&#9;parts[i] = strings.ToLower(strings.TrimSpace(parts[i]))&#10;&#9;//&#9;}&#10;&#9;//&#9;cfg.ReportFormats = parts&#10;&#9;//}&#10;&#10;&#9;if err := cfg.Validate(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return cfg, nil&#10;}&#10;&#10;// Run 是一个便利包装，解析 flags 并分派到相应处理器。&#10;// 用你实际的内部/核心逻辑替换占位处理调用。&#10;func Run() error {&#10;&#9;cfg, err := ParseFlags()&#10;&#9;if err != nil {&#10;&#9;&#9;if errors.Is(err, flag.ErrHelp) {&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;}&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 下载模式优先&#10;&#9;if cfg.Download {&#10;&#9;&#9;// 获取 DSN：优先 CLI 的 DBDSN，否则环境变量&#10;&#9;&#9;//dsn := cfg.DBDSN&#10;&#9;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;&#9;dsn = os.Getenv(&quot;DATABASE_URL&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;未提供数据库 DSN（通过 -dbdsn 或环境变量 DATABASE_URL）&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;// 初始化 DB 连接池&#10;&#9;&#9;pool, err := config.InitDB(dsn)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;初始化数据库失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;// 创建下载器；rpc url 必须提供&#10;&#9;&#9;rpcURL := cfg.RPCURL&#10;&#9;&#9;if rpcURL == &quot;&quot; {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;下载模式需要 -rpc 指定以太坊节点 RPC URL&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;dl, err := download.NewDownloader(rpcURL, pool)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;创建下载器失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;// 使用超时上下文（基于 cfg.Timeout）&#10;&#9;&#9;ctx, cancel := context.WithTimeout(context.Background(), cfg.Timeout)&#10;&#9;&#9;defer cancel()&#10;&#9;&#9;defer dl.Close()&#10;&#10;&#9;&#9;// 如果提供了下载范围，使用 DownloadBlockRange，否则使用 DownloadFromLast&#10;&#9;&#9;if cfg.DownloadRange != nil {&#10;&#9;&#9;&#9;start := cfg.DownloadRange.Start&#10;&#9;&#9;&#9;end := cfg.DownloadRange.End&#10;&#9;&#9;&#9;if end == ^uint64(0) {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;下载范围的结束区块不能为空&quot;)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if err := dl.DownloadBlockRange(ctx, start, end); err != nil {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;下载失败: %w&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;if err := dl.DownloadFromLast(ctx); err != nil {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;从上次继续下载失败: %w&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;// 下载完成后直接返回&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;使用配置运行 Excavator: %+v\n&quot;, cfg)&#10;&#9;}&#10;&#10;&#9;// 将 CLIConfig 映射到 internal.ScanConfig&#10;&#9;internalCfg := internal.ScanConfig{&#10;&#9;&#9;AIProvider:   cfg.AIProvider,&#10;&#9;&#9;Mode:         cfg.Mode,&#10;&#9;&#9;Strategy:     cfg.Strategy,&#10;&#9;&#9;TargetSource: cfg.TargetSource,&#10;&#9;&#9;TargetFile:   cfg.TargetFile,&#10;&#9;&#9;Chain:        cfg.Chain,&#10;&#9;&#9;Concurrency:  cfg.Concurrency,&#10;&#9;&#9;Verbose:      cfg.Verbose,&#10;&#9;&#9;Timeout:      cfg.Timeout,&#10;&#9;}&#10;&#9;if cfg.BlockRange != nil {&#10;&#9;&#9;internalCfg.BlockRange = &amp;internal.BlockRange{&#10;&#9;&#9;&#9;Start: cfg.BlockRange.Start,&#10;&#9;&#9;&#9;End:   cfg.BlockRange.End,&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// TODO: 与内部/核心处理器集成。下面为示例分派。&#10;&#9;switch cfg.Mode {&#10;&#9;case &quot;mode1&quot;:&#10;&#9;&#9;results, err := handler.RunMode1(internalCfg)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;Mode1 扫描失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;fmt.Printf(&quot;Mode1 扫描完成，共找到 %d 个漏洞条目\n&quot;, len(results))&#10;&#9;case &quot;mode2&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode2（模糊）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;case &quot;mode3&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode3（通用）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;default:&#10;&#9;&#9;return errors.New(&quot;unsupported mode&quot;)&#10;&#9;}&#10;&#10;&#9;// Reporter 集成点（占位）&#10;&#9;//if cfg.ReportEnabled {&#10;&#9;//&#9;// 目前这里仅为占位提示 —— 实际应调用 internal/reporter 生成并保存报告。&#10;&#9;//&#9;// 示例伪代码：&#10;&#9;//&#9;// reportManager := reporter.New(cfg.ReportOut)&#10;&#9;//&#9;// meta, err := reportManager.Generate(ctx, scanResult, cfg.ReportFormats)&#10;&#9;//&#9;// if err != nil { log... }&#10;&#9;//&#9;// if cfg.ReportNotify { reportManager.Notify(meta) }&#10;&#9;//&#9;fmt.Printf(&quot;报告已启用 → 格式: %v, 输出: %s\n&quot;, cfg.ReportFormats, cfg.ReportOut)&#10;&#9;//}&#10;&#9;return nil&#10;}&#10;&#10;// 小帮助函数：PrintFatal 将错误打印到 stderr 并以非零代码退出。&#10;func PrintFatal(err error) {&#10;&#9;if err == nil {&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;fmt.Fprintln(os.Stderr, &quot;错误:&quot;, err)&#10;&#9;os.Exit(1)&#10;}&#10;" />
              <option name="updatedContent" value="package cmd&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;flag&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/config&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/download&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/handler&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// Reporter 先不写&#10;&#10;// CLIConfig 保存解析好的 CLI 选项以及供扫描器使用的规范化字&#10;// 段。&#10;type CLIConfig struct {&#10;&#9;AIProvider   string // 例如 chatgpt5&#10;&#9;Mode         string // mode1 | mode2 | mode3&#10;&#9;Strategy     string // 例如 hourglass-vul 或 &quot;all&quot;&#10;&#9;TargetSource string // &quot;db&quot; 或 &quot;file&quot; - 从哪里获取目标列表&#10;&#9;BlockRange   *BlockRange&#10;&#9;TargetFile   string // 包含地址/批次的 YAML 路径&#10;&#9;Chain        string // eth | bsc | arb&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#10;&#9;// 下载相关配置&#10;&#9;Download      bool        // -d 启动下载流程&#10;&#9;DownloadRange *BlockRange // -d-range 指定下载区块范围（格式 start-end），为空表示从上次继续下载&#10;}&#10;&#10;// BlockRange 简单的起止区块范围结构&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;func (b *BlockRange) String() string {&#10;&#9;if b == nil {&#10;&#9;&#9;return &quot;&quot;&#10;&#9;}&#10;&#9;return fmt.Sprintf(&quot;%d-%d&quot;, b.Start, b.End)&#10;}&#10;&#10;// parseBlockRange 解析类似 &quot;1-220234&quot; 或 &quot;1000-&quot;（开放结束）的字符串并返回 BlockRange。&#10;func parseBlockRange(s string) (*BlockRange, error) {&#10;&#9;if strings.TrimSpace(s) == &quot;&quot; {&#10;&#9;&#9;return nil, nil&#10;&#9;}&#10;&#9;parts := strings.Split(s, &quot;-&quot;)&#10;&#9;if len(parts) != 2 {&#10;&#9;&#9;return nil, errors.New(&quot;invalid block range format, expected start-end&quot;)&#10;&#9;}&#10;&#9;startStr := strings.TrimSpace(parts[0])&#10;&#9;endStr := strings.TrimSpace(parts[1])&#10;&#9;var br BlockRange&#10;&#9;if startStr == &quot;&quot; {&#10;&#9;&#9;return nil, errors.New(&quot;start block required&quot;)&#10;&#9;}&#10;&#9;start, err := strconv.ParseUint(startStr, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid start block: %w&quot;, err)&#10;&#9;}&#10;&#9;br.Start = start&#10;&#9;if endStr == &quot;&quot; {&#10;&#9;&#9;br.End = ^uint64(0) // max uint64 to indicate open-ended&#10;&#9;} else {&#10;&#9;&#9;end, err := strconv.ParseUint(endStr, 10, 64)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;invalid end block: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if end &lt; start {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;end block must be &gt;= start block&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;br.End = end&#10;&#9;}&#10;&#9;return &amp;br, nil&#10;}&#10;&#10;// Validate 检查 CLIConfig 的必需/一致性输入。&#10;func (c *CLIConfig) Validate() error {&#10;&#9;// 如果是下载模式，仅需要下载相关配置&#10;&#9;if c.Download {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;if c.AIProvider == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-ai is required (e.g. -ai chatgpt5)&quot;)&#10;&#9;}&#10;&#9;if c.Mode == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-m (mode) is required: mode1|mode2|mode3&quot;)&#10;&#9;}&#10;&#9;if c.Mode != &quot;mode1&quot; &amp;&amp; c.Mode != &quot;mode2&quot; &amp;&amp; c.Mode != &quot;mode3&quot; {&#10;&#9;&#9;return errors.New(&quot;-m must be one of: mode1, mode2, mode3&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource != &quot;db&quot; &amp;&amp; c.TargetSource != &quot;file&quot; {&#10;&#9;&#9;return errors.New(&quot;-t must be either 'db' or 'file'&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource == &quot;file&quot; &amp;&amp; c.TargetFile == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-t-file is required when -t=file&quot;)&#10;&#9;}&#10;&#9;if c.Chain == &quot;&quot; {&#10;&#9;&#9;c.Chain = &quot;eth&quot; // default&#10;&#9;}&#10;&#9;if c.Concurrency &lt;= 0 {&#10;&#9;&#9;c.Concurrency = 4&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// ParseFlags 解析 os.Args 并返回 CLIConfig 或错误。用于从 main 调用。&#10;func ParseFlags() (*CLIConfig, error) {&#10;&#9;fs := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)&#10;&#9;fs.Usage = func() {&#10;&#9;&#9;w := fs.Output()&#10;&#9;&#9;fmt.Fprintln(w, &quot;用法: excavator -ai &lt;provider&gt; -m &lt;mode&gt; [选项]&quot;)&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;选项:&quot;)&#10;&#9;&#9;fs.PrintDefaults()&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;示例:&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s hourglass-vul -t file -t-file ./data/source_contracts/sample.yaml -c eth&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s all -t db -t-block 1-220234 -c eth&quot;)&#10;&#9;}&#10;&#10;&#9;// 新增下载相关 flags（不包含 rpc/dbdsn）&#10;&#9;downloadFlag := fs.Bool(&quot;d&quot;, false, &quot;启动区块/合约下载流程（从数据库记录的最后区块继续，或使用 -d-range 指定范围）&quot;)&#10;&#9;drange := fs.String(&quot;d-range&quot;, &quot;&quot;, &quot;下载区块范围（format start-end），与 -d 一起使用时覆盖从上次继续的行为&quot;)&#10;&#10;&#9;ai := fs.String(&quot;ai&quot;, &quot;&quot;, &quot;AI provider to use (e.g. chatgpt5)&quot;)&#10;&#9;mode := fs.String(&quot;m&quot;, &quot;&quot;, &quot;Mode to run: mode1(targeted) | mode2(fuzzy) | mode3(general)&quot;)&#10;&#9;strategy := fs.String(&quot;s&quot;, &quot;all&quot;, &quot;Strategy/prompt name in strategy/prompts/&lt;mode&gt;/ (or 'all')&quot;)&#10;&#9;target := fs.String(&quot;t&quot;, &quot;db&quot;, &quot;Target source: 'db' or 'file' (default db)&quot;)&#10;&#9;blockRange := fs.String(&quot;t-block&quot;, &quot;&quot;, &quot;Block range for scanning (format start-end, e.g. 1-220234)&quot;)&#10;&#9;tfile := fs.String(&quot;t-file&quot;, &quot;&quot;, &quot;YAML file path when -t=file; can be a directory for batching&quot;)&#10;&#9;chain := fs.String(&quot;c&quot;, &quot;eth&quot;, &quot;Chain to scan: eth | bsc | arb (default eth)&quot;)&#10;&#9;concurrency := fs.Int(&quot;concurrency&quot;, 4, &quot;Worker concurrency&quot;)&#10;&#9;verbose := fs.Bool(&quot;v&quot;, false, &quot;Verbose output&quot;)&#10;&#9;timeout := fs.Duration(&quot;timeout&quot;, 30*time.Second, &quot;Per-AI request timeout&quot;)&#10;&#10;&#9;if err := fs.Parse(os.Args[1:]); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;cfg := &amp;CLIConfig{&#10;&#9;&#9;AIProvider:   strings.TrimSpace(*ai),&#10;&#9;&#9;Mode:         strings.TrimSpace(*mode),&#10;&#9;&#9;Strategy:     strings.TrimSpace(*strategy),&#10;&#9;&#9;TargetSource: strings.TrimSpace(*target),&#10;&#9;&#9;TargetFile:   strings.TrimSpace(*tfile),&#10;&#9;&#9;Chain:        strings.TrimSpace(*chain),&#10;&#9;&#9;Concurrency:  *concurrency,&#10;&#9;&#9;Verbose:      *verbose,&#10;&#9;&#9;Timeout:      *timeout,&#10;&#9;&#9;Download:     *downloadFlag,&#10;&#9;}&#10;&#10;&#9;// 解析下载区块范围（如果提供）&#10;&#9;if strings.TrimSpace(*drange) != &quot;&quot; {&#10;&#9;&#9;br, err := parseBlockRange(*drange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;cfg.DownloadRange = br&#10;&#9;}&#10;&#10;&#9;if strings.TrimSpace(*blockRange) != &quot;&quot; {&#10;&#9;&#9;br, err := parseBlockRange(*blockRange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;cfg.BlockRange = br&#10;&#9;}&#10;&#10;&#9;// normalize target source&#10;&#9;cfg.TargetSource = strings.ToLower(cfg.TargetSource)&#10;&#9;if cfg.TargetSource == &quot;yaml&quot; {&#10;&#9;&#9;cfg.TargetSource = &quot;file&quot; // accept yaml alias&#10;&#9;}&#10;&#10;&#9;// 如果提供了文件路径但不是绝对路径，则将其转为相对于当前工作目录&#10;&#9;if cfg.TargetFile != &quot;&quot; {&#10;&#9;&#9;if !filepath.IsAbs(cfg.TargetFile) {&#10;&#9;&#9;&#9;cwd, _ := os.Getwd()&#10;&#9;&#9;&#9;cfg.TargetFile = filepath.Join(cwd, cfg.TargetFile)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if err := cfg.Validate(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return cfg, nil&#10;}&#10;&#10;// Run 是一个便利包装，解析 flags 并分派到相应处理器。&#10;// 用你实际的内部/核心逻辑替换占位处理调用。&#10;func Run() error {&#10;&#9;cfg, err := ParseFlags()&#10;&#9;if err != nil {&#10;&#9;&#9;if errors.Is(err, flag.ErrHelp) {&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;}&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 下载模式优先&#10;&#9;if cfg.Download {&#10;&#9;&#9;// 获取 DSN：使用环境变量 DATABASE_URL&#10;&#9;&#9;dsn := os.Getenv(&quot;DATABASE_URL&quot;)&#10;&#9;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;未提供数据库 DSN，请设置环境变量 DATABASE_URL&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;// 初始化 DB 连接池&#10;&#9;&#9;pool, err := config.InitDB(dsn)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;初始化数据库失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 从 config 中获取 RPC URL（优先环境变量 RPC_URL，或读取 src/config/rpc.txt）&#10;&#9;&#9;rpcURL, err := config.GetRPCURL()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;获取 RPC URL 失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;dl, err := download.NewDownloader(rpcURL, pool)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;创建下载器失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;// 使用超时上下文（基于 cfg.Timeout）&#10;&#9;&#9;ctx, cancel := context.WithTimeout(context.Background(), cfg.Timeout)&#10;&#9;&#9;defer cancel()&#10;&#9;&#9;defer dl.Close()&#10;&#10;&#9;&#9;// 如果提供了下载范围，使用 DownloadBlockRange，否则使用 DownloadFromLast&#10;&#9;&#9;if cfg.DownloadRange != nil {&#10;&#9;&#9;&#9;start := cfg.DownloadRange.Start&#10;&#9;&#9;&#9;end := cfg.DownloadRange.End&#10;&#9;&#9;&#9;if end == ^uint64(0) {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;下载范围的结束区块不能为空&quot;)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if err := dl.DownloadBlockRange(ctx, start, end); err != nil {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;下载失败: %w&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;if err := dl.DownloadFromLast(ctx); err != nil {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;从上次继续下载失败: %w&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;// 下载完成后直接返回&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;使用配置运行 Excavator: %+v\n&quot;, cfg)&#10;&#9;}&#10;&#10;&#9;// 将 CLIConfig 映射到 internal.ScanConfig&#10;&#9;internalCfg := internal.ScanConfig{&#10;&#9;&#9;AIProvider:   cfg.AIProvider,&#10;&#9;&#9;Mode:         cfg.Mode,&#10;&#9;&#9;Strategy:     cfg.Strategy,&#10;&#9;&#9;TargetSource: cfg.TargetSource,&#10;&#9;&#9;TargetFile:   cfg.TargetFile,&#10;&#9;&#9;Chain:        cfg.Chain,&#10;&#9;&#9;Concurrency:  cfg.Concurrency,&#10;&#9;&#9;Verbose:      cfg.Verbose,&#10;&#9;&#9;Timeout:      cfg.Timeout,&#10;&#9;}&#10;&#9;if cfg.BlockRange != nil {&#10;&#9;&#9;internalCfg.BlockRange = &amp;internal.BlockRange{&#10;&#9;&#9;&#9;Start: cfg.BlockRange.Start,&#10;&#9;&#9;&#9;End:   cfg.BlockRange.End,&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// TODO: 与内部/核心处理器集成。下面为示例分派。&#10;&#9;switch cfg.Mode {&#10;&#9;case &quot;mode1&quot;:&#10;&#9;&#9;results, err := handler.RunMode1(internalCfg)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;Mode1 扫描失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;fmt.Printf(&quot;Mode1 扫描完成，共找到 %d 个漏洞条目\n&quot;, len(results))&#10;&#9;case &quot;mode2&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode2（模糊）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;case &quot;mode3&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode3（通用）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;default:&#10;&#9;&#9;return errors.New(&quot;unsupported mode&quot;)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// 小帮助函数：PrintFatal 将错误打印到 stderr 并以非零代码退出。&#10;func PrintFatal(err error) {&#10;&#9;if err == nil {&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;fmt.Fprintln(os.Stderr, &quot;错误:&quot;, err)&#10;&#9;os.Exit(1)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config/database.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config/database.go" />
              <option name="originalContent" value="package config&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;&quot;github.com/jackc/pgx/v5/pgxpool&quot;&#10;)&#10;&#10;// 全局连接池（可选使用）&#10;var DBPool *pgxpool.Pool&#10;&#10;// InitDB 初始化 pgx 连接池并 ping 验证&#10;func InitDB(dsn string) (*pgxpool.Pool, error) {&#10;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;InitDB: empty dsn&quot;)&#10;&#9;}&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;defer cancel()&#10;&#9;pool, err := pgxpool.New(ctx, dsn)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;InitDB: %w&quot;, err)&#10;&#9;}&#10;&#9;if err := pool.Ping(ctx); err != nil {&#10;&#9;&#9;pool.Close()&#10;&#9;&#9;return nil, fmt.Errorf(&quot;InitDB ping failed: %w&quot;, err)&#10;&#9;}&#10;&#9;DBPool = pool&#10;&#9;return pool, nil&#10;}&#10;&#10;// GetContracts 从 contracts 表读取记录，limit&lt;=0 表示不限制&#10;func GetContracts(ctx context.Context, pool *pgxpool.Pool, limit int) ([]internal.Contract, error) {&#10;&#9;if pool == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;GetContracts: pool is nil&quot;)&#10;&#9;}&#10;&#9;q := &quot;SELECT address, contract, balance, isopensource, createtime, createblock, txlast FROM contracts&quot;&#10;&#9;var rows pgxpool.Rows&#10;&#9;var err error&#10;&#9;if limit &gt; 0 {&#10;&#9;&#9;rows, err = pool.Query(ctx, q+&quot; LIMIT $1&quot;, limit)&#10;&#9;} else {&#10;&#9;&#9;rows, err = pool.Query(ctx, q)&#10;&#9;}&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer rows.Close()&#10;&#10;&#9;var out []internal.Contract&#10;&#9;for rows.Next() {&#10;&#9;&#9;var c internal.Contract&#10;&#9;&#9;var isOpenInt int&#10;&#9;&#9;var createBlockInt int64&#10;&#9;&#9;var createtime time.Time&#10;&#9;&#9;var txlast time.Time&#10;&#9;&#9;var balance string&#10;&#9;&#9;if err := rows.Scan(&amp;c.Address, &amp;c.Code, &amp;balance, &amp;isOpenInt, &amp;createtime, &amp;createBlockInt, &amp;txlast); err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;c.Balance = balance&#10;&#9;&#9;c.IsOpenSource = isOpenInt != 0&#10;&#9;&#9;c.CreateTime = createtime&#10;&#9;&#9;c.CreateBlock = uint64(createBlockInt)&#10;&#9;&#9;c.TxLast = txlast&#10;&#9;&#9;out = append(out, c)&#10;&#9;}&#10;&#9;if rows.Err() != nil {&#10;&#9;&#9;return nil, rows.Err()&#10;&#9;}&#10;&#9;return out, nil&#10;}&#10;&#10;// GetContractsByAddresses 根据地址数组批量查询（使用 ANY($1::text[])）&#10;func GetContractsByAddresses(ctx context.Context, pool *pgxpool.Pool, addresses []string) ([]internal.Contract, error) {&#10;&#9;if pool == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;GetContractsByAddresses: pool is nil&quot;)&#10;&#9;}&#10;&#9;if len(addresses) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;GetContractsByAddresses: addresses empty&quot;)&#10;&#9;}&#10;&#9;q := &quot;SELECT address, contract, balance, isopensource, createtime, createblock, txlast FROM contracts WHERE address = ANY($1::text[])&quot;&#10;&#9;rows, err := pool.Query(ctx, q, addresses)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer rows.Close()&#10;&#10;&#9;var out []internal.Contract&#10;&#9;for rows.Next() {&#10;&#9;&#9;var c internal.Contract&#10;&#9;&#9;var isOpenInt int&#10;&#9;&#9;var createBlockInt int64&#10;&#9;&#9;var createtime time.Time&#10;&#9;&#9;var txlast time.Time&#10;&#9;&#9;var balance string&#10;&#9;&#9;if err := rows.Scan(&amp;c.Address, &amp;c.Code, &amp;balance, &amp;isOpenInt, &amp;createtime, &amp;createBlockInt, &amp;txlast); err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;c.Balance = balance&#10;&#9;&#9;c.IsOpenSource = isOpenInt != 0&#10;&#9;&#9;c.CreateTime = createtime&#10;&#9;&#9;c.CreateBlock = uint64(createBlockInt)&#10;&#9;&#9;c.TxLast = txlast&#10;&#9;&#9;out = append(out, c)&#10;&#9;}&#10;&#9;if rows.Err() != nil {&#10;&#9;&#9;return nil, rows.Err()&#10;&#9;}&#10;&#9;return out, nil&#10;}&#10;" />
              <option name="updatedContent" value="package config&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;&quot;github.com/jackc/pgx/v5/pgxpool&quot;&#10;)&#10;&#10;// 全局连接池（可选使用）&#10;var DBPool *pgxpool.Pool&#10;&#10;// InitDB 初始化 pgx 连接池并 ping 验证&#10;func InitDB(dsn string) (*pgxpool.Pool, error) {&#10;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;InitDB: empty dsn&quot;)&#10;&#9;}&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;defer cancel()&#10;&#9;pool, err := pgxpool.New(ctx, dsn)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;InitDB: %w&quot;, err)&#10;&#9;}&#10;&#9;if err := pool.Ping(ctx); err != nil {&#10;&#9;&#9;pool.Close()&#10;&#9;&#9;return nil, fmt.Errorf(&quot;InitDB ping failed: %w&quot;, err)&#10;&#9;}&#10;&#9;DBPool = pool&#10;&#9;return pool, nil&#10;}&#10;&#10;// GetContracts 从 contracts 表读取记录，limit&lt;=0 表示不限制&#10;func GetContracts(ctx context.Context, pool *pgxpool.Pool, limit int) ([]internal.Contract, error) {&#10;&#9;if pool == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;GetContracts: pool is nil&quot;)&#10;&#9;}&#10;&#9;q := &quot;SELECT address, contract, balance, isopensource, createtime, createblock, txlast FROM contracts&quot;&#10;&#9;var rows pgxpool.Rows&#10;&#9;var err error&#10;&#9;if limit &gt; 0 {&#10;&#9;&#9;rows, err = pool.Query(ctx, q+&quot; LIMIT $1&quot;, limit)&#10;&#9;} else {&#10;&#9;&#9;rows, err = pool.Query(ctx, q)&#10;&#9;}&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer rows.Close()&#10;&#10;&#9;var out []internal.Contract&#10;&#9;for rows.Next() {&#10;&#9;&#9;var c internal.Contract&#10;&#9;&#9;var isOpenInt int&#10;&#9;&#9;var createBlockInt int64&#10;&#9;&#9;var createtime time.Time&#10;&#9;&#9;var txlast time.Time&#10;&#9;&#9;var balance string&#10;&#9;&#9;if err := rows.Scan(&amp;c.Address, &amp;c.Code, &amp;balance, &amp;isOpenInt, &amp;createtime, &amp;createBlockInt, &amp;txlast); err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;c.Balance = balance&#10;&#9;&#9;c.IsOpenSource = isOpenInt != 0&#10;&#9;&#9;c.CreateTime = createtime&#10;&#9;&#9;c.CreateBlock = uint64(createBlockInt)&#10;&#9;&#9;c.TxLast = txlast&#10;&#9;&#9;out = append(out, c)&#10;&#9;}&#10;&#9;if rows.Err() != nil {&#10;&#9;&#9;return nil, rows.Err()&#10;&#9;}&#10;&#9;return out, nil&#10;}&#10;&#10;// GetContractsByAddresses 根据地址数组批量查询（使用 ANY($1::text[])）&#10;func GetContractsByAddresses(ctx context.Context, pool *pgxpool.Pool, addresses []string) ([]internal.Contract, error) {&#10;&#9;if pool == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;GetContractsByAddresses: pool is nil&quot;)&#10;&#9;}&#10;&#9;if len(addresses) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;GetContractsByAddresses: addresses empty&quot;)&#10;&#9;}&#10;&#9;q := &quot;SELECT address, contract, balance, isopensource, createtime, createblock, txlast FROM contracts WHERE address = ANY($1::text[])&quot;&#10;&#9;rows, err := pool.Query(ctx, q, addresses)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer rows.Close()&#10;&#10;&#9;var out []internal.Contract&#10;&#9;for rows.Next() {&#10;&#9;&#9;var c internal.Contract&#10;&#9;&#9;var isOpenInt int&#10;&#9;&#9;var createBlockInt int64&#10;&#9;&#9;var createtime time.Time&#10;&#9;&#9;var txlast time.Time&#10;&#9;&#9;var balance string&#10;&#9;&#9;if err := rows.Scan(&amp;c.Address, &amp;c.Code, &amp;balance, &amp;isOpenInt, &amp;createtime, &amp;createBlockInt, &amp;txlast); err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;c.Balance = balance&#10;&#9;&#9;c.IsOpenSource = isOpenInt != 0&#10;&#9;&#9;c.CreateTime = createtime&#10;&#9;&#9;c.CreateBlock = uint64(createBlockInt)&#10;&#9;&#9;c.TxLast = txlast&#10;&#9;&#9;out = append(out, c)&#10;&#9;}&#10;&#9;if rows.Err() != nil {&#10;&#9;&#9;return nil, rows.Err()&#10;&#9;}&#10;&#9;return out, nil&#10;}&#10;&#10;// GetRPCURL 返回用于连接以太坊节点的 RPC URL。&#10;// 优先使用环境变量 RPC_URL；若未设置，则尝试读取常见路径下的 rpc.txt 文件（例如 ./src/config/rpc.txt 或 ./config/rpc.txt）。&#10;func GetRPCURL() (string, error) {&#10;&#9;// 优先环境变量&#10;&#9;if v := strings.TrimSpace(os.Getenv(&quot;RPC_URL&quot;)); v != &quot;&quot; {&#10;&#9;&#9;return v, nil&#10;&#9;}&#10;&#9;// 尝试读取文件&#10;&#9;paths := []string{&#10;&#9;&#9;&quot;./src/config/rpc.txt&quot;,&#10;&#9;&#9;&quot;./config/rpc.txt&quot;,&#10;&#9;&#9;&quot;./rpc.txt&quot;,&#10;&#9;}&#10;&#9;for _, p := range paths {&#10;&#9;&#9;b, err := os.ReadFile(p)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;if s := strings.TrimSpace(string(b)); s != &quot;&quot; {&#10;&#9;&#9;&#9;return s, nil&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return &quot;&quot;, fmt.Errorf(&quot;RPC_URL 未配置：请设置环境变量 RPC_URL 或在 src/config/rpc.txt 提供 RPC URL&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/ai/parser/parser.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/ai/parser/parser.go" />
              <option name="originalContent" value="package ai&#10;&#10;// Parser 全局占位对象&#10;var Parser = &amp;aiParser{}&#10;&#10;type aiParser struct{}&#10;&#10;// Parse 将原始 AI 输出转换为结构化 ScanResult&#10;func (p *aiParser) Parse(raw string) ([]ScanResult, error) {&#10;&#9;// TODO: 解析 AI 输出&#10;&#9;return []ScanResult{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;ContractAddress: &quot;0xDEADBEEF&quot;,&#10;&#9;&#9;&#9;Vulnerability:   &quot;MockVul&quot;,&#10;&#9;&#9;&#9;Severity:        &quot;High&quot;,&#10;&#9;&#9;&#9;Details:         raw,&#10;&#9;&#9;&#9;Line:            1,&#10;&#9;&#9;},&#10;&#9;}, nil&#10;}&#10;" />
              <option name="updatedContent" value="package parser&#10;&#10;// Parser 全局占位对象&#10;var Parser = &amp;aiParser{}&#10;&#10;type aiParser struct{}&#10;&#10;// Parse 将原始 AI 输出转换为结构化 ScanResult&#10;func (p *aiParser) Parse(raw string) ([]ScanResult, error) {&#10;&#9;// TODO: 解析 AI 输出&#10;&#9;return []ScanResult{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;ContractAddress: &quot;0xDEADBEEF&quot;,&#10;&#9;&#9;&#9;Vulnerability:   &quot;MockVul&quot;,&#10;&#9;&#9;&#9;Severity:        &quot;High&quot;,&#10;&#9;&#9;&#9;Details:         raw,&#10;&#9;&#9;&#9;Line:            1,&#10;&#9;&#9;},&#10;&#9;}, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/ai/parser/schema.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/ai/parser/schema.go" />
              <option name="originalContent" value="package ai&#10;&#10;type ScanResult struct {&#10;&#9;ContractAddress string&#10;&#9;Vulnerability   string&#10;&#9;Severity        string&#10;&#9;Details         string&#10;&#9;Line            int&#10;}&#10;" />
              <option name="updatedContent" value="package parser&#10;&#10;type ScanResult struct {&#10;&#9;ContractAddress string&#10;&#9;Vulnerability   string&#10;&#9;Severity        string&#10;&#9;Details         string&#10;&#9;Line            int&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/core/mode1.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/core/mode1.go" />
              <option name="originalContent" value="package core&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/cmd&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/types&quot;&#10;)&#10;&#10;// Mode1Scan 扫描合约并返回原始 AI 输出（占位实现）&#10;func Mode1Scan(contract types.Contract, prompt string, expCode string, cfg *cmd.CLIConfig) (string, error) {&#10;&#9;// TODO: 实际扫描逻辑，例如调用 AI 或分析 EXP&#10;&#9;return fmt.Sprintf(&quot;Mock AI 输出 for %s&quot;, contract.Address), nil&#10;}&#10;" />
              <option name="updatedContent" value="package core&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;)&#10;&#10;// Mode1Scan 扫描合约并返回原始 AI 输出（占位实现）&#10;func Mode1Scan(contract internal.Contract, prompt string, expCode string, cfg internal.ScanConfig) (string, error) {&#10;&#9;// TODO: 实际扫描逻辑，例如调用 AI 或分析 EXP&#10;&#9;return fmt.Sprintf(&quot;Mock AI 输出 for %s&quot;, contract.Address), nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/handler/mode1_targeted.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/handler/mode1_targeted.go" />
              <option name="originalContent" value="package handler&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/config&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;parser &quot;github.com/admi-n/solidity-Excavator/src/internal/ai/parser&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/core&quot;&#10;)&#10;&#10;// RunMode1 执行 Mode1 定向扫描&#10;func RunMode1(cfg internal.ScanConfig) ([]parser.ScanResult, error) {&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Println(&quot;[Mode1] 启动定向扫描...&quot;)&#10;&#9;}&#10;&#10;&#9;// 1️⃣ 获取目标合约列表&#10;&#9;targets, err := loadTargets(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;[Mode1] 加载目标失败: %w&quot;, err)&#10;&#9;}&#10;&#9;if len(targets) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;[Mode1] 未找到扫描目标&quot;)&#10;&#9;}&#10;&#10;&#9;var results []parser.ScanResult&#10;&#10;&#9;// 2️⃣ 遍历每个合约&#10;&#9;for _, contract := range targets {&#10;&#9;&#9;if cfg.Verbose {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 扫描合约: %s\n&quot;, contract.Address)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2a. 构建 Prompt&#10;&#9;&#9;prompt := buildPrompt(cfg, contract)&#10;&#9;&#9;// 2b. 加载漏洞复现 EXP (占位)&#10;&#9;&#9;expCode := loadExp(cfg.Strategy)&#10;&#10;&#9;&#9;// 2c. 调用 Core 层执行扫描&#10;&#9;&#9;rawOutput, err := core.Mode1Scan(contract, prompt, expCode, cfg)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 警告: 扫描合约 %s 失败: %v\n&quot;, contract.Address, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2d. 调用 AI Parser 将原始输出转换为 ScanResult&#10;&#9;&#9;structured, err := parser.Parser.Parse(rawOutput)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 警告: 解析合约 %s 输出失败: %v\n&quot;, contract.Address, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;results = append(results, structured...)&#10;&#10;&#9;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;}&#10;&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;[Mode1] 扫描完成，找到 %d 个漏洞条目\n&quot;, len(results))&#10;&#9;}&#10;&#10;&#9;return results, nil&#10;}&#10;&#10;// loadTargets 占位函数：根据 cfg.TargetSource 获取目标合约列表&#10;func loadTargets(cfg internal.ScanConfig) ([]internal.Contract, error) {&#10;&#9;// 如果目标来自数据库，则尝试从 PostgreSQL 拉取（使用 DATABASE_URL 环境变量或者外部传入的 DSN）&#10;&#9;if cfg.TargetSource == &quot;db&quot; {&#10;&#9;&#9;dsn := os.Getenv(&quot;DATABASE_URL&quot;)&#10;&#9;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;DATABASE_URL 未设置，无法从数据库加载目标&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;pool, err := config.InitDB(dsn)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;初始化数据库失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;// 使用短超时的 context 加载数据&#10;&#9;&#9;ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)&#10;&#9;&#9;defer cancel()&#10;&#9;&#9;// limit 可根据需求调整；这里使用 1000 为示例&#10;&#9;&#9;contracts, err := config.GetContracts(ctx, pool, 1000)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;从数据库加载合约失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;return contracts, nil&#10;&#9;}&#10;&#10;&#9;// 默认回退：file 或 mock（方便本地测试）&#10;&#9;mock := []internal.Contract{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Address: &quot;0xDEADBEEF...&quot;,&#10;&#9;&#9;&#9;Code:    &quot;contract Mock { function test() public {} }&quot;,&#10;&#9;&#9;&#9;// 其余字段可为空/零值&#10;&#9;&#9;},&#10;&#9;}&#10;&#9;return mock, nil&#10;}&#10;&#10;// buildPrompt 占位函数&#10;func buildPrompt(cfg internal.ScanConfig, contract internal.Contract) string {&#10;&#9;return fmt.Sprintf(&quot;请分析合约 %s 的漏洞，使用策略 %s&quot;, contract.Address, cfg.Strategy)&#10;}&#10;&#10;// loadExp 占位函数&#10;func loadExp(strategy string) string {&#10;&#9;return &quot;// 漏洞复现代码占位&quot;&#10;}&#10;" />
              <option name="updatedContent" value="package handler&#10;&#10;import (&#10;&#9;&quot;bufio&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/config&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;parser &quot;github.com/admi-n/solidity-Excavator/src/internal/ai/parser&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/core&quot;&#10;)&#10;&#10;// RunMode1 执行 Mode1 定向扫描&#10;func RunMode1(cfg internal.ScanConfig) ([]parser.ScanResult, error) {&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Println(&quot;[Mode1] 启动定向扫描...&quot;)&#10;&#9;}&#10;&#10;&#9;// 1️⃣ 获取目标合约列表&#10;&#9;targets, err := loadTargets(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;[Mode1] 加载目标失败: %w&quot;, err)&#10;&#9;}&#10;&#9;if len(targets) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;[Mode1] 未找到扫描目标&quot;)&#10;&#9;}&#10;&#10;&#9;var results []parser.ScanResult&#10;&#10;&#9;// 2️⃣ 遍历每个合约&#10;&#9;for _, contract := range targets {&#10;&#9;&#9;if cfg.Verbose {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 扫描合约: %s\n&quot;, contract.Address)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2a. 构建 Prompt&#10;&#9;&#9;prompt := buildPrompt(cfg, contract)&#10;&#9;&#9;// 2b. 加载漏洞复现 EXP (占位)&#10;&#9;&#9;expCode := loadExp(cfg.Strategy)&#10;&#10;&#9;&#9;// 2c. 调用 Core 层执行扫描&#10;&#9;&#9;rawOutput, err := core.Mode1Scan(contract, prompt, expCode, cfg)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 警告: 扫描合约 %s 失败: %v\n&quot;, contract.Address, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2d. 调用 AI Parser 将原始输出转换为 ScanResult&#10;&#9;&#9;structured, err := parser.Parser.Parse(rawOutput)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 警告: 解析合约 %s 输出失败: %v\n&quot;, contract.Address, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;results = append(results, structured...)&#10;&#10;&#9;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;}&#10;&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;[Mode1] 扫描完成，找到 %d 个漏洞条目\n&quot;, len(results))&#10;&#9;}&#10;&#10;&#9;return results, nil&#10;}&#10;&#10;// loadTargets 占位函数：根据 cfg.TargetSource 获取目标合约列表&#10;func loadTargets(cfg internal.ScanConfig) ([]internal.Contract, error) {&#10;&#9;// 如果目标来自数据库（直接拉取全表或分页），保留现有行为&#10;&#9;if cfg.TargetSource == &quot;db&quot; {&#10;&#9;&#9;dsn := os.Getenv(&quot;DATABASE_URL&quot;)&#10;&#9;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;DATABASE_URL 未设置，无法从数据库加载目标&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;pool, err := config.InitDB(dsn)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;初始化数据库失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;// 使用短超时的 context 加载数据&#10;&#9;&#9;ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)&#10;&#9;&#9;defer cancel()&#10;&#9;&#9;// limit 可根据需求调整；这里使用 1000 为示例&#10;&#9;&#9;contracts, err := config.GetContracts(ctx, pool, 1000)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;从数据库加载合约失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;return contracts, nil&#10;&#9;}&#10;&#10;&#9;// 如果目标来自文件（txt），则读取每行地址并用数据库按地址匹配合约信息&#10;&#9;if cfg.TargetSource == &quot;file&quot; {&#10;&#9;&#9;if cfg.TargetFile == &quot;&quot; {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;cfg.TargetFile 为空，无法读取地址文件&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;f, err := os.Open(cfg.TargetFile)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;打开地址文件失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;defer f.Close()&#10;&#10;&#9;&#9;var addrs []string&#10;&#9;&#9;scanner := bufio.NewScanner(f)&#10;&#9;&#9;for scanner.Scan() {&#10;&#9;&#9;&#9;line := strings.TrimSpace(scanner.Text())&#10;&#9;&#9;&#9;if line == &quot;&quot; {&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;addrs = append(addrs, line)&#10;&#9;&#9;}&#10;&#9;&#9;if err := scanner.Err(); err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;读取地址文件失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if len(addrs) == 0 {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;地址文件中未找到任何地址&quot;)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 使用 DB 来匹配这些地址并获取合约信息&#10;&#9;&#9;dsn := os.Getenv(&quot;DATABASE_URL&quot;)&#10;&#9;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;DATABASE_URL 未设置，无法从数据库加载目标&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;pool, err := config.InitDB(dsn)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;初始化数据库失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)&#10;&#9;&#9;defer cancel()&#10;&#9;&#9;contracts, err := config.GetContractsByAddresses(ctx, pool, addrs)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;按地址从数据库加载合约失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;return contracts, nil&#10;&#9;}&#10;&#10;&#9;// 默认回退：mock（方便本地测试）&#10;&#9;mock := []internal.Contract{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Address: &quot;0xDEADBEEF...&quot;,&#10;&#9;&#9;&#9;Code:    &quot;contract Mock { function test() public {} }&quot;,&#10;&#9;&#9;&#9;// 其余字段可为空/零值&#10;&#9;&#9;},&#10;&#9;}&#10;&#9;return mock, nil&#10;}&#10;&#10;// buildPrompt 占位函数&#10;func buildPrompt(cfg internal.ScanConfig, contract internal.Contract) string {&#10;&#9;return fmt.Sprintf(&quot;请分析合约 %s 的漏洞，使用策略 %s&quot;, contract.Address, cfg.Strategy)&#10;}&#10;&#10;// loadExp 占位函数&#10;func loadExp(strategy string) string {&#10;&#9;return &quot;// 漏洞复现代码占位&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/types.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/types.go" />
              <option name="originalContent" value="package internal&#10;&#10;import &quot;time&quot;&#10;&#10;type ScanConfig struct {&#10;&#9;AIProvider   string&#10;&#9;Mode         string&#10;&#9;Strategy     string&#10;&#9;TargetSource string&#10;&#9;TargetFile   string&#10;&#9;Chain        string&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#9;BlockRange   *BlockRange&#10;}&#10;&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;// 新增：表示待扫描的合约基础信息&#10;type Contract struct {&#10;&#9;Address string&#10;&#9;Code    string&#10;}&#10;" />
              <option name="updatedContent" value="package internal&#10;&#10;import &quot;time&quot;&#10;&#10;type ScanConfig struct {&#10;&#9;AIProvider   string&#10;&#9;Mode         string&#10;&#9;Strategy     string&#10;&#9;TargetSource string&#10;&#9;TargetFile   string&#10;&#9;Chain        string&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#9;BlockRange   *BlockRange&#10;}&#10;&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;// Contract 表示待扫描的合约基础信息，包含数据库表字段映射&#10;type Contract struct {&#10;&#9;Address      string    `json:&quot;address&quot;`       // 合约地址&#10;&#9;Code         string    `json:&quot;contract&quot;`      // 合约代码&#10;&#9;Balance      string    `json:&quot;balance&quot;`       // 余额（以字符串保存以避免精度/类型问题）&#10;&#9;IsOpenSource bool      `json:&quot;isOpenSource&quot;`  // 是否开源 (true/false 对应 1/0)&#10;&#9;CreateTime   time.Time `json:&quot;createtime&quot;`    // 创建时间&#10;&#9;CreateBlock  uint64    `json:&quot;createblock&quot;`   // 创建区块号&#10;&#9;TxLast       time.Time `json:&quot;txlast&quot;`        // 最后一次交互时间&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>