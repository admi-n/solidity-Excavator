<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/cmd/cli.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/cmd/cli.go" />
              <option name="originalContent" value="package cmd&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;flag&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/config&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/download&quot;&#10;)&#10;&#10;// Reporter 先不写&#10;&#10;// CLIConfig 保存解析好的 CLI 选项以及供扫描器使用的规范化字段。&#10;type CLIConfig struct {&#10;&#9;AIProvider   string // 例如 chatgpt5&#10;&#9;Mode         string // mode1 | mode2 | mode3&#10;&#9;Strategy     string // 例如 hourglass-vul 或 &quot;all&quot;&#10;&#9;TargetSource string // &quot;db&quot; 或 &quot;file&quot; - 从哪里获取目标列表&#10;&#9;BlockRange   *BlockRange&#10;&#9;TargetFile   string // 包含地址/批次的 YAML 路径&#10;&#9;Chain        string // eth | bsc | arb&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#10;&#9;// 下载相关配置&#10;&#9;Download      bool        // -d 启动下载流程&#10;&#9;DownloadRange *BlockRange // -d-range 指定下载区块范围（格式 start-end），为空表示从上次继续下载&#10;&#10;&#9;Proxy string // 新增：HTTP 代理 (例如 http://127.0.0.1:7897)&#10;}&#10;&#10;// BlockRange 简单的起止区块范围结构&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;func (b *BlockRange) String() string {&#10;&#9;if b == nil {&#10;&#9;&#9;return &quot;&quot;&#10;&#9;}&#10;&#9;return fmt.Sprintf(&quot;%d-%d&quot;, b.Start, b.End)&#10;}&#10;&#10;// parseBlockRange 解析类似 &quot;1-220234&quot; 或 &quot;1000-&quot;（开放结束）的字符串并返回 BlockRange。&#10;func parseBlockRange(s string) (*BlockRange, error) {&#10;&#9;if strings.TrimSpace(s) == &quot;&quot; {&#10;&#9;&#9;return nil, nil&#10;&#9;}&#10;&#9;parts := strings.Split(s, &quot;-&quot;)&#10;&#9;if len(parts) != 2 {&#10;&#9;&#9;return nil, errors.New(&quot;invalid block range format, expected start-end&quot;)&#10;&#9;}&#10;&#9;startStr := strings.TrimSpace(parts[0])&#10;&#9;endStr := strings.TrimSpace(parts[1])&#10;&#9;var br BlockRange&#10;&#9;if startStr == &quot;&quot; {&#10;&#9;&#9;return nil, errors.New(&quot;start block required&quot;)&#10;&#9;}&#10;&#9;start, err := strconv.ParseUint(startStr, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid start block: %w&quot;, err)&#10;&#9;}&#10;&#9;br.Start = start&#10;&#9;if endStr == &quot;&quot; {&#10;&#9;&#9;br.End = ^uint64(0) // max uint64 to indicate open-ended&#10;&#9;} else {&#10;&#9;&#9;end, err := strconv.ParseUint(endStr, 10, 64)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;invalid end block: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if end &lt; start {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;end block must be &gt;= start block&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;br.End = end&#10;&#9;}&#10;&#9;return &amp;br, nil&#10;}&#10;&#10;// Validate 检查 CLIConfig 的必需/一致性输入。&#10;func (c *CLIConfig) Validate() error {&#10;&#9;// 如果是下载模式，仅需要下载相关配置&#10;&#9;if c.Download {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;if c.AIProvider == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-ai is required (e.g. -ai chatgpt5)&quot;)&#10;&#9;}&#10;&#9;if c.Mode == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-m (mode) is required: mode1|mode2|mode3&quot;)&#10;&#9;}&#10;&#9;if c.Mode != &quot;mode1&quot; &amp;&amp; c.Mode != &quot;mode2&quot; &amp;&amp; c.Mode != &quot;mode3&quot; {&#10;&#9;&#9;return errors.New(&quot;-m must be one of: mode1, mode2, mode3&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource != &quot;db&quot; &amp;&amp; c.TargetSource != &quot;file&quot; {&#10;&#9;&#9;return errors.New(&quot;-t must be either 'db' or 'file'&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource == &quot;file&quot; &amp;&amp; c.TargetFile == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-t-file is required when -t=file&quot;)&#10;&#9;}&#10;&#9;if c.Chain == &quot;&quot; {&#10;&#9;&#9;c.Chain = &quot;eth&quot; // default&#10;&#9;}&#10;&#9;if c.Concurrency &lt;= 0 {&#10;&#9;&#9;c.Concurrency = 4&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// ParseFlags 解析 os.Args 并返回 CLIConfig 或错误。用于从 main 调用。&#10;func ParseFlags() (*CLIConfig, error) {&#10;&#9;fs := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)&#10;&#9;fs.Usage = func() {&#10;&#9;&#9;w := fs.Output()&#10;&#9;&#9;fmt.Fprintln(w, &quot;用法: excavator -ai &lt;provider&gt; -m &lt;mode&gt; [选项]&quot;)&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;选项:&quot;)&#10;&#9;&#9;fs.PrintDefaults()&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;示例:&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s hourglass-vul -t file -t-file ./data/source_contracts/sample.yaml -c eth&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s all -t db -t-block 1-220234 -c eth&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -d                    # 从上次继续下载&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -d -d-range 1000-2000 # 下载指定区块范围&quot;)&#10;&#9;}&#10;&#10;&#9;// 新增下载相关 flags（不包含 rpc/dbdsn）&#10;&#9;downloadFlag := fs.Bool(&quot;d&quot;, false, &quot;启动区块/合约下载流程（从数据库记录的最后区块继续，或使用 -d-range 指定范围）&quot;)&#10;&#9;drange := fs.String(&quot;d-range&quot;, &quot;&quot;, &quot;下载区块范围（format start-end），与 -d 一起使用时覆盖从上次继续的行为&quot;)&#10;&#9;proxy := fs.String(&quot;proxy&quot;, &quot;&quot;, &quot;可选 HTTP 代理，例如 http://127.0.0.1:7897（下载/请求 Etherscan 时生效）&quot;)&#10;&#10;&#9;ai := fs.String(&quot;ai&quot;, &quot;&quot;, &quot;AI provider to use (e.g. chatgpt5)&quot;)&#10;&#9;mode := fs.String(&quot;m&quot;, &quot;&quot;, &quot;Mode to run: mode1(targeted) | mode2(fuzzy) | mode3(general)&quot;)&#10;&#9;strategy := fs.String(&quot;s&quot;, &quot;all&quot;, &quot;Strategy/prompt name in strategy/prompts/&lt;mode&gt;/ (or 'all')&quot;)&#10;&#9;target := fs.String(&quot;t&quot;, &quot;db&quot;, &quot;Target source: 'db' or 'file' (default db)&quot;)&#10;&#9;blockRange := fs.String(&quot;t-block&quot;, &quot;&quot;, &quot;Block range for scanning (format start-end, e.g. 1-220234)&quot;)&#10;&#9;tfile := fs.String(&quot;t-file&quot;, &quot;&quot;, &quot;YAML file path when -t=file; can be a directory for batching&quot;)&#10;&#9;chain := fs.String(&quot;c&quot;, &quot;eth&quot;, &quot;Chain to scan: eth | bsc | arb (default eth)&quot;)&#10;&#9;concurrency := fs.Int(&quot;concurrency&quot;, 4, &quot;Worker concurrency&quot;)&#10;&#9;verbose := fs.Bool(&quot;v&quot;, false, &quot;Verbose output&quot;)&#10;&#9;timeout := fs.Duration(&quot;timeout&quot;, 30*time.Second, &quot;Per-AI request timeout&quot;)&#10;&#10;&#9;if err := fs.Parse(os.Args[1:]); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;cfg := &amp;CLIConfig{&#10;&#9;&#9;AIProvider:   strings.TrimSpace(*ai),&#10;&#9;&#9;Mode:         strings.TrimSpace(*mode),&#10;&#9;&#9;Strategy:     strings.TrimSpace(*strategy),&#10;&#9;&#9;TargetSource: strings.TrimSpace(*target),&#10;&#9;&#9;TargetFile:   strings.TrimSpace(*tfile),&#10;&#9;&#9;Chain:        strings.TrimSpace(*chain),&#10;&#9;&#9;Concurrency:  *concurrency,&#10;&#9;&#9;Verbose:      *verbose,&#10;&#9;&#9;Timeout:      *timeout,&#10;&#9;&#9;Download:     *downloadFlag,&#10;&#9;&#9;Proxy:        strings.TrimSpace(*proxy),&#10;&#9;}&#10;&#10;&#9;// 解析下载区块范围（如果提供）&#10;&#9;if strings.TrimSpace(*drange) != &quot;&quot; {&#10;&#9;&#9;br, err := parseBlockRange(*drange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;cfg.DownloadRange = br&#10;&#9;}&#10;&#10;&#9;if strings.TrimSpace(*blockRange) != &quot;&quot; {&#10;&#9;&#9;br, err := parseBlockRange(*blockRange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;cfg.BlockRange = br&#10;&#9;}&#10;&#10;&#9;// normalize target source&#10;&#9;cfg.TargetSource = strings.ToLower(cfg.TargetSource)&#10;&#9;if cfg.TargetSource == &quot;yaml&quot; {&#10;&#9;&#9;cfg.TargetSource = &quot;file&quot; // accept yaml alias&#10;&#9;}&#10;&#10;&#9;// 如果提供了文件路径但不是绝对路径，则将其转为相对于当前工作目录&#10;&#9;if cfg.TargetFile != &quot;&quot; {&#10;&#9;&#9;if !filepath.IsAbs(cfg.TargetFile) {&#10;&#9;&#9;&#9;cwd, _ := os.Getwd()&#10;&#9;&#9;&#9;cfg.TargetFile = filepath.Join(cwd, cfg.TargetFile)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if err := cfg.Validate(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return cfg, nil&#10;}&#10;&#10;// Run 是一个便利包装，解析 flags 并分派到相应处理器。&#10;// 用你实际的内部/核心逻辑替换占位处理调用。&#10;func Run() error {&#10;&#9;cfg, err := ParseFlags()&#10;&#9;if err != nil {&#10;&#9;&#9;if errors.Is(err, flag.ErrHelp) {&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;}&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 下载模式优先&#10;&#9;if cfg.Download {&#10;&#9;&#9;fmt.Println(&quot; 启动合约下载器...&quot;)&#10;&#10;&#9;&#9;// 初始化 MySQL 数据库连接（使用 config.InitDB，不需要传 DSN）&#10;&#9;&#9;fmt.Println(&quot; 正在连接 MySQL 数据库...&quot;)&#10;&#9;&#9;db, err := config.InitDB()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;初始化数据库失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;defer db.Close()&#10;&#9;&#9;fmt.Println(&quot;✅ 数据库连接成功!&quot;)&#10;&#10;&#9;&#9;// 创建下载器（会自动从 config.GetRPCURL() 读取 RPC URL），传入 proxy&#10;&#9;&#9;fmt.Println(&quot; 正在创建下载器...&quot;)&#10;&#9;&#9;dl, err := download.NewDownloader(db, cfg.Proxy)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;创建下载器失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;defer dl.Close()&#10;&#10;&#9;&#9;// 创建上下文（使用较长的超时时间用于下载）&#10;&#9;&#9;ctx := context.Background()&#10;&#10;&#9;&#9;fmt.Println(&quot;\n&quot; + strings.Repeat(&quot;=&quot;, 50))&#10;&#9;&#9;fmt.Println(&quot;开始同步合约数据...&quot;)&#10;&#9;&#9;fmt.Println(strings.Repeat(&quot;=&quot;, 50) + &quot;\n&quot;)&#10;&#10;&#9;&#9;// 如果提供了下载范围，使用 DownloadBlockRange，否则使用 DownloadFromLast&#10;&#9;&#9;if cfg.DownloadRange != nil {&#10;&#9;&#9;&#9;start := cfg.DownloadRange.Start&#10;&#9;&#9;&#9;end := cfg.DownloadRange.End&#10;&#9;&#9;&#9;if end == ^uint64(0) {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;下载范围的结束区块不能为空&quot;)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;fmt.Printf(&quot; 下载指定区块范围: %d 到 %d\n&quot;, start, end)&#10;&#9;&#9;&#9;if err := dl.DownloadBlockRange(ctx, start, end); err != nil {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;下载失败: %w&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;fmt.Println(&quot; 从上次下载位置继续...&quot;)&#10;&#9;&#9;&#9;if err := dl.DownloadFromLast(ctx); err != nil {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;从上次继续下载失败: %w&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;fmt.Println(&quot;\n 下载任务完成!&quot;)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 非下载模式：正常的扫描流程&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;使用配置运行 Excavator: %+v\n&quot;, cfg)&#10;&#9;}&#10;&#10;&#9;// 将 CLIConfig 映射到 internal.ScanConfig&#10;&#9;internalCfg := internal.ScanConfig{&#10;&#9;&#9;AIProvider:   cfg.AIProvider,&#10;&#9;&#9;Mode:         cfg.Mode,&#10;&#9;&#9;Strategy:     cfg.Strategy,&#10;&#9;&#9;TargetSource: cfg.TargetSource,&#10;&#9;&#9;TargetFile:   cfg.TargetFile,&#10;&#9;&#9;Chain:        cfg.Chain,&#10;&#9;&#9;Concurrency:  cfg.Concurrency,&#10;&#9;&#9;Verbose:      cfg.Verbose,&#10;&#9;&#9;Timeout:      cfg.Timeout,&#10;&#9;}&#10;&#9;if cfg.BlockRange != nil {&#10;&#9;&#9;internalCfg.BlockRange = &amp;internal.BlockRange{&#10;&#9;&#9;&#9;Start: cfg.BlockRange.Start,&#10;&#9;&#9;&#9;End:   cfg.BlockRange.End,&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// TODO: 与内部/核心处理器集成。下面为示例分派。&#10;&#9;switch cfg.Mode {&#10;&#9;case &quot;mode1&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode1）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;&#9;//results, err := handler.RunMode1(internalCfg)&#10;&#9;&#9;//if err != nil {&#10;&#9;&#9;//&#9;return fmt.Errorf(&quot;Mode1 扫描失败: %w&quot;, err)&#10;&#9;&#9;//}&#10;&#9;&#9;//fmt.Printf(&quot;Mode1 扫描完成，共找到 %d 个漏洞条目\n&quot;, len(results))&#10;&#9;case &quot;mode2&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode2（模糊）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;case &quot;mode3&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode3（通用）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;default:&#10;&#9;&#9;return errors.New(&quot;unsupported mode&quot;)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// PrintFatal 将错误打印到 stderr 并以非零代码退出。&#10;func PrintFatal(err error) {&#10;&#9;if err == nil {&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;fmt.Fprintln(os.Stderr, &quot;错误:&quot;, err)&#10;&#9;os.Exit(1)&#10;}&#10;" />
              <option name="updatedContent" value="package cmd&#10;&#10;import (&#10;&#9;&quot;bufio&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;flag&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/config&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/download&quot;&#10;)&#10;&#10;// Reporter 先不写&#10;&#10;// CLIConfig 保存解析好的 CLI 选项以及供扫描器使用的规范化字段。&#10;type CLIConfig struct {&#10;&#9;AIProvider   string // 例如 chatgpt5&#10;&#9;Mode         string // mode1 | mode2 | mode3&#10;&#9;Strategy     string // 例如 hourglass-vul 或 &quot;all&quot;&#10;&#9;TargetSource string // &quot;db&quot; 或 &quot;file&quot; - 从哪里获取目标列表&#10;&#9;BlockRange   *BlockRange&#10;&#9;TargetFile   string // 包含地址/批次的 YAML 路径&#10;&#9;Chain        string // eth | bsc | arb&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#10;&#9;// 下载相关配置&#10;&#9;Download      bool        // -d 启动下载流程&#10;&#9;DownloadRange *BlockRange // -d-range 指定下载区块范围（格式 start-end），为空表示从上次继续下载&#10;&#9;DownloadFile  string      // -file 指定包含地址的 txt 文件（每行一个地址），用于重试下载&#10;&#10;&#9;Proxy string // 新增：HTTP 代理 (例如 http://127.0.0.1:7897)&#10;}&#10;&#10;// BlockRange 简单的起止区块范围结构&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;func (b *BlockRange) String() string {&#10;&#9;if b == nil {&#10;&#9;&#9;return &quot;&quot;&#10;&#9;}&#10;&#9;return fmt.Sprintf(&quot;%d-%d&quot;, b.Start, b.End)&#10;}&#10;&#10;// parseBlockRange 解析类似 &quot;1-220234&quot; 或 &quot;1000-&quot;（开放结束）的字符串并返回 BlockRange。&#10;func parseBlockRange(s string) (*BlockRange, error) {&#10;&#9;if strings.TrimSpace(s) == &quot;&quot; {&#10;&#9;&#9;return nil, nil&#10;&#9;}&#10;&#9;parts := strings.Split(s, &quot;-&quot;)&#10;&#9;if len(parts) != 2 {&#10;&#9;&#9;return nil, errors.New(&quot;invalid block range format, expected start-end&quot;)&#10;&#9;}&#10;&#9;startStr := strings.TrimSpace(parts[0])&#10;&#9;endStr := strings.TrimSpace(parts[1])&#10;&#9;var br BlockRange&#10;&#9;if startStr == &quot;&quot; {&#10;&#9;&#9;return nil, errors.New(&quot;start block required&quot;)&#10;&#9;}&#10;&#9;start, err := strconv.ParseUint(startStr, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid start block: %w&quot;, err)&#10;&#9;}&#10;&#9;br.Start = start&#10;&#9;if endStr == &quot;&quot; {&#10;&#9;&#9;br.End = ^uint64(0) // max uint64 to indicate open-ended&#10;&#9;} else {&#10;&#9;&#9;end, err := strconv.ParseUint(endStr, 10, 64)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;invalid end block: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if end &lt; start {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;end block must be &gt;= start block&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;br.End = end&#10;&#9;}&#10;&#9;return &amp;br, nil&#10;}&#10;&#10;// Validate 检查 CLIConfig 的必需/一致性输入。&#10;func (c *CLIConfig) Validate() error {&#10;&#9;// 如果是下载模式，仅需要下载相关配置&#10;&#9;if c.Download {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;if c.AIProvider == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-ai is required (e.g. -ai chatgpt5)&quot;)&#10;&#9;}&#10;&#9;if c.Mode == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-m (mode) is required: mode1|mode2|mode3&quot;)&#10;&#9;}&#10;&#9;if c.Mode != &quot;mode1&quot; &amp;&amp; c.Mode != &quot;mode2&quot; &amp;&amp; c.Mode != &quot;mode3&quot; {&#10;&#9;&#9;return errors.New(&quot;-m must be one of: mode1, mode2, mode3&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource != &quot;db&quot; &amp;&amp; c.TargetSource != &quot;file&quot; {&#10;&#9;&#9;return errors.New(&quot;-t must be either 'db' or 'file'&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource == &quot;file&quot; &amp;&amp; c.TargetFile == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-t-file is required when -t=file&quot;)&#10;&#9;}&#10;&#9;if c.Chain == &quot;&quot; {&#10;&#9;&#9;c.Chain = &quot;eth&quot; // default&#10;&#9;}&#10;&#9;if c.Concurrency &lt;= 0 {&#10;&#9;&#9;c.Concurrency = 4&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// ParseFlags 解析 os.Args 并返回 CLIConfig 或错误。用于从 main 调用。&#10;func ParseFlags() (*CLIConfig, error) {&#10;&#9;fs := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)&#10;&#9;fs.Usage = func() {&#10;&#9;&#9;w := fs.Output()&#10;&#9;&#9;fmt.Fprintln(w, &quot;用法: excavator -ai &lt;provider&gt; -m &lt;mode&gt; [选项]&quot;)&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;选项:&quot;)&#10;&#9;&#9;fs.PrintDefaults()&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;示例:&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s hourglass-vul -t file -t-file ./data/source_contracts/sample.yaml -c eth&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s all -t db -t-block 1-220234 -c eth&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -d                    # 从上次继续下载&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -d -d-range 1000-2000 # 下载指定区块范围&quot;)&#10;&#9;}&#10;&#10;&#9;// 新增下载相关 flags（不包含 rpc/dbdsn）&#10;&#9;downloadFlag := fs.Bool(&quot;d&quot;, false, &quot;启动区块/合约下载流程（从数据库记录的最后区块继续，或使用 -d-range 指定范围）&quot;)&#10;&#9;drange := fs.String(&quot;d-range&quot;, &quot;&quot;, &quot;下载区块范围（format start-end），与 -d 一起使用时覆盖从上次继续的行为&quot;)&#10;&#9;proxy := fs.String(&quot;proxy&quot;, &quot;&quot;, &quot;可选 HTTP 代理，例如 http://127.0.0.1:7897（下载/请求 Etherscan 时生效）&quot;)&#10;&#10;&#9;ai := fs.String(&quot;ai&quot;, &quot;&quot;, &quot;AI provider to use (e.g. chatgpt5)&quot;)&#10;&#9;mode := fs.String(&quot;m&quot;, &quot;&quot;, &quot;Mode to run: mode1(targeted) | mode2(fuzzy) | mode3(general)&quot;)&#10;&#9;strategy := fs.String(&quot;s&quot;, &quot;all&quot;, &quot;Strategy/prompt name in strategy/prompts/&lt;mode&gt;/ (or 'all')&quot;)&#10;&#9;target := fs.String(&quot;t&quot;, &quot;db&quot;, &quot;Target source: 'db' or 'file' (default db)&quot;)&#10;&#9;blockRange := fs.String(&quot;t-block&quot;, &quot;&quot;, &quot;Block range for scanning (format start-end, e.g. 1-220234)&quot;)&#10;&#9;tfile := fs.String(&quot;t-file&quot;, &quot;&quot;, &quot;YAML file path when -t=file; can be a directory for batching&quot;)&#10;&#9;chain := fs.String(&quot;c&quot;, &quot;eth&quot;, &quot;Chain to scan: eth | bsc | arb (default eth)&quot;)&#10;&#9;concurrency := fs.Int(&quot;concurrency&quot;, 4, &quot;Worker concurrency&quot;)&#10;&#9;verbose := fs.Bool(&quot;v&quot;, false, &quot;Verbose output&quot;)&#10;&#9;timeout := fs.Duration(&quot;timeout&quot;, 30*time.Second, &quot;Per-AI request timeout&quot;)&#10;&#9;fileFlag := fs.String(&quot;file&quot;, &quot;&quot;, &quot;当 -d 一起使用时，从指定 txt 文件读取地址逐条重新下载（每行一个地址）&quot;)&#10;&#10;&#9;if err := fs.Parse(os.Args[1:]); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;cfg := &amp;CLIConfig{&#10;&#9;&#9;AIProvider:   strings.TrimSpace(*ai),&#10;&#9;&#9;Mode:         strings.TrimSpace(*mode),&#10;&#9;&#9;Strategy:     strings.TrimSpace(*strategy),&#10;&#9;&#9;TargetSource: strings.TrimSpace(*target),&#10;&#9;&#9;TargetFile:   strings.TrimSpace(*tfile),&#10;&#9;&#9;Chain:        strings.TrimSpace(*chain),&#10;&#9;&#9;Concurrency:  *concurrency,&#10;&#9;&#9;Verbose:      *verbose,&#10;&#9;&#9;Timeout:      *timeout,&#10;&#9;&#9;Download:     *downloadFlag,&#10;&#9;&#9;Proxy:        strings.TrimSpace(*proxy),&#10;&#9;&#9;DownloadFile: strings.TrimSpace(*fileFlag),&#10;&#9;}&#10;&#10;&#9;// 解析下载区块范围（如果提供）&#10;&#9;if strings.TrimSpace(*drange) != &quot;&quot; {&#10;&#9;&#9;br, err := parseBlockRange(*drange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;cfg.DownloadRange = br&#10;&#9;}&#10;&#10;&#9;if strings.TrimSpace(*blockRange) != &quot;&quot; {&#10;&#9;&#9;br, err := parseBlockRange(*blockRange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;cfg.BlockRange = br&#10;&#9;}&#10;&#10;&#9;// normalize target source&#10;&#9;cfg.TargetSource = strings.ToLower(cfg.TargetSource)&#10;&#9;if cfg.TargetSource == &quot;yaml&quot; {&#10;&#9;&#9;cfg.TargetSource = &quot;file&quot; // accept yaml alias&#10;&#9;}&#10;&#10;&#9;// 如果提供了文件路径但不是绝对路径，则将其转为相对于当前工作目录&#10;&#9;if cfg.TargetFile != &quot;&quot; {&#10;&#9;&#9;if !filepath.IsAbs(cfg.TargetFile) {&#10;&#9;&#9;&#9;cwd, _ := os.Getwd()&#10;&#9;&#9;&#9;cfg.TargetFile = filepath.Join(cwd, cfg.TargetFile)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if err := cfg.Validate(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return cfg, nil&#10;}&#10;&#10;// Run 是一个便利包装，解析 flags 并分派到相应处理器。&#10;// 用你实际的内部/核心逻辑替换占位处理调用。&#10;func Run() error {&#10;&#9;cfg, err := ParseFlags()&#10;&#9;if err != nil {&#10;&#9;&#9;if errors.Is(err, flag.ErrHelp) {&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;}&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 下载模式优先&#10;&#9;if cfg.Download {&#10;&#9;&#9;fmt.Println(&quot; 启动合约下载器...&quot;)&#10;&#10;&#9;&#9;// 初始化 MySQL 数据库连接（使用 config.InitDB，不需要传 DSN）&#10;&#9;&#9;fmt.Println(&quot; 正在连接 MySQL 数据库...&quot;)&#10;&#9;&#9;db, err := config.InitDB()&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;初始化数据库失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;defer db.Close()&#10;&#9;&#9;fmt.Println(&quot;✅ 数据库连接成功!&quot;)&#10;&#10;&#9;&#9;// 创建下载器（会自动从 config.GetRPCURL() 读取 RPC URL），传入 proxy&#10;&#9;&#9;fmt.Println(&quot; 正在创建下载器...&quot;)&#10;&#9;&#9;dl, err := download.NewDownloader(db, cfg.Proxy)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;创建下载器失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;defer dl.Close()&#10;&#10;&#9;&#9;// 创建上下文（使用较长的超时时间用于下载）&#10;&#9;&#9;ctx := context.Background()&#10;&#10;&#9;&#9;fmt.Println(&quot;\n&quot; + strings.Repeat(&quot;=&quot;, 50))&#10;&#9;&#9;fmt.Println(&quot;开始同步合约数据...&quot;)&#10;&#9;&#9;fmt.Println(strings.Repeat(&quot;=&quot;, 50) + &quot;\n&quot;)&#10;&#10;&#9;&#9;// 如果提供了下载范围，使用 DownloadBlockRange，否则使用 DownloadFromLast&#10;&#9;&#9;if cfg.DownloadRange != nil {&#10;&#9;&#9;&#9;start := cfg.DownloadRange.Start&#10;&#9;&#9;&#9;end := cfg.DownloadRange.End&#10;&#9;&#9;&#9;if end == ^uint64(0) {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;下载范围的结束区块不能为空&quot;)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;fmt.Printf(&quot; 下载指定区块范围: %d 到 %d\n&quot;, start, end)&#10;&#9;&#9;&#9;if err := dl.DownloadBlockRange(ctx, start, end); err != nil {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;下载失败: %w&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;fmt.Println(&quot; 从上次下载位置继续...&quot;)&#10;&#9;&#9;&#9;if err := dl.DownloadFromLast(ctx); err != nil {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;从上次继续下载失败: %w&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 如果用户传入 -file，则从该文件读取地址并逐条重试下载&#10;&#9;&#9;if cfg.DownloadFile != &quot;&quot; {&#10;&#9;&#9;&#9;// 读取文件中的地址（每行一个），去重并传给下载器&#10;&#9;&#9;&#9;fpath := cfg.DownloadFile&#10;&#9;&#9;&#9;f, err := os.Open(fpath)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;打开地址文件失败: %w&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;scanner := bufio.NewScanner(f)&#10;&#9;&#9;&#9;var addrs []string&#10;&#9;&#9;&#9;for scanner.Scan() {&#10;&#9;&#9;&#9;&#9;line := strings.TrimSpace(scanner.Text())&#10;&#9;&#9;&#9;&#9;if line == &quot;&quot; {&#10;&#9;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;addrs = append(addrs, line)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;f.Close()&#10;&#9;&#9;&#9;if err := scanner.Err(); err != nil {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;读取地址文件失败: %w&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;if len(addrs) == 0 {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;地址文件为空: %s&quot;, fpath)&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;// 将未下载成功的地址写入默认失败文件 eoferror.txt&#10;&#9;&#9;&#9;failLog := &quot;eoferror.txt&quot;&#10;&#9;&#9;&#9;fmt.Printf(&quot; 正在根据 %s 重试 %d 个地址，失败将记录到 %s\n&quot;, fpath, len(addrs), failLog)&#10;&#9;&#9;&#9;if err := dl.DownloadContractsByAddresses(ctx, addrs, failLog); err != nil {&#10;&#9;&#9;&#9;&#9;return fmt.Errorf(&quot;按地址下载失败: %w&quot;, err)&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;fmt.Println(&quot;\n 地址重试下载完成!&quot;)&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 否则按区块范围/从上次继续下载（原有逻辑）&#10;&#9;&#9;fmt.Println(&quot;\n 下载任务完成!&quot;)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 非下载模式：正常的扫描流程&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;使用配置运行 Excavator: %+v\n&quot;, cfg)&#10;&#9;}&#10;&#10;&#9;// 将 CLIConfig 映射到 internal.ScanConfig&#10;&#9;internalCfg := internal.ScanConfig{&#10;&#9;&#9;AIProvider:   cfg.AIProvider,&#10;&#9;&#9;Mode:         cfg.Mode,&#10;&#9;&#9;Strategy:     cfg.Strategy,&#10;&#9;&#9;TargetSource: cfg.TargetSource,&#10;&#9;&#9;TargetFile:   cfg.TargetFile,&#10;&#9;&#9;Chain:        cfg.Chain,&#10;&#9;&#9;Concurrency:  cfg.Concurrency,&#10;&#9;&#9;Verbose:      cfg.Verbose,&#10;&#9;&#9;Timeout:      cfg.Timeout,&#10;&#9;}&#10;&#9;if cfg.BlockRange != nil {&#10;&#9;&#9;internalCfg.BlockRange = &amp;internal.BlockRange{&#10;&#9;&#9;&#9;Start: cfg.BlockRange.Start,&#10;&#9;&#9;&#9;End:   cfg.BlockRange.End,&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// TODO: 与内部/核心处理器集成。下面为示例分派。&#10;&#9;switch cfg.Mode {&#10;&#9;case &quot;mode1&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode1）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;&#9;//results, err := handler.RunMode1(internalCfg)&#10;&#9;&#9;//if err != nil {&#10;&#9;&#9;//&#9;return fmt.Errorf(&quot;Mode1 扫描失败: %w&quot;, err)&#10;&#9;&#9;//}&#10;&#9;&#9;//fmt.Printf(&quot;Mode1 扫描完成，共找到 %d 个漏洞条目\n&quot;, len(results))&#10;&#9;case &quot;mode2&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode2（模糊）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;case &quot;mode3&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode3（通用）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;default:&#10;&#9;&#9;return errors.New(&quot;unsupported mode&quot;)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// PrintFatal 将错误打印到 stderr 并以非零代码退出。&#10;func PrintFatal(err error) {&#10;&#9;if err == nil {&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;fmt.Fprintln(os.Stderr, &quot;错误:&quot;, err)&#10;&#9;os.Exit(1)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/config/database.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/config/database.go" />
              <option name="originalContent" value="package config&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;&quot;github.com/jackc/pgx/v5/pgxpool&quot;&#10;)&#10;&#10;// 全局连接池（可选使用）&#10;var DBPool *pgxpool.Pool&#10;&#10;// InitDB 初始化 pgx 连接池并 ping 验证&#10;func InitDB(dsn string) (*pgxpool.Pool, error) {&#10;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;InitDB: empty dsn&quot;)&#10;&#9;}&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;defer cancel()&#10;&#9;pool, err := pgxpool.New(ctx, dsn)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;InitDB: %w&quot;, err)&#10;&#9;}&#10;&#9;if err := pool.Ping(ctx); err != nil {&#10;&#9;&#9;pool.Close()&#10;&#9;&#9;return nil, fmt.Errorf(&quot;InitDB ping failed: %w&quot;, err)&#10;&#9;}&#10;&#9;DBPool = pool&#10;&#9;return pool, nil&#10;}&#10;&#10;// GetContracts 从 contracts 表读取记录，limit&lt;=0 表示不限制&#10;func GetContracts(ctx context.Context, pool *pgxpool.Pool, limit int) ([]internal.Contract, error) {&#10;&#9;if pool == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;GetContracts: pool is nil&quot;)&#10;&#9;}&#10;&#9;q := &quot;SELECT address, contract, balance, isopensource, createtime, createblock, txlast FROM contracts&quot;&#10;&#9;var rows pgxpool.Rows&#10;&#9;var err error&#10;&#9;if limit &gt; 0 {&#10;&#9;&#9;rows, err = pool.Query(ctx, q+&quot; LIMIT $1&quot;, limit)&#10;&#9;} else {&#10;&#9;&#9;rows, err = pool.Query(ctx, q)&#10;&#9;}&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer rows.Close()&#10;&#10;&#9;var out []internal.Contract&#10;&#9;for rows.Next() {&#10;&#9;&#9;var c internal.Contract&#10;&#9;&#9;var isOpenInt int&#10;&#9;&#9;var createBlockInt int64&#10;&#9;&#9;var createtime time.Time&#10;&#9;&#9;var txlast time.Time&#10;&#9;&#9;var balance string&#10;&#9;&#9;if err := rows.Scan(&amp;c.Address, &amp;c.Code, &amp;balance, &amp;isOpenInt, &amp;createtime, &amp;createBlockInt, &amp;txlast); err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;c.Balance = balance&#10;&#9;&#9;c.IsOpenSource = isOpenInt != 0&#10;&#9;&#9;c.CreateTime = createtime&#10;&#9;&#9;c.CreateBlock = uint64(createBlockInt)&#10;&#9;&#9;c.TxLast = txlast&#10;&#9;&#9;out = append(out, c)&#10;&#9;}&#10;&#9;if rows.Err() != nil {&#10;&#9;&#9;return nil, rows.Err()&#10;&#9;}&#10;&#9;return out, nil&#10;}&#10;&#10;// GetContractsByAddresses 根据地址数组批量查询（使用 ANY($1::text[])）&#10;func GetContractsByAddresses(ctx context.Context, pool *pgxpool.Pool, addresses []string) ([]internal.Contract, error) {&#10;&#9;if pool == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;GetContractsByAddresses: pool is nil&quot;)&#10;&#9;}&#10;&#9;if len(addresses) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;GetContractsByAddresses: addresses empty&quot;)&#10;&#9;}&#10;&#9;q := &quot;SELECT address, contract, balance, isopensource, createtime, createblock, txlast FROM contracts WHERE address = ANY($1::text[])&quot;&#10;&#9;rows, err := pool.Query(ctx, q, addresses)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer rows.Close()&#10;&#10;&#9;var out []internal.Contract&#10;&#9;for rows.Next() {&#10;&#9;&#9;var c internal.Contract&#10;&#9;&#9;var isOpenInt int&#10;&#9;&#9;var createBlockInt int64&#10;&#9;&#9;var createtime time.Time&#10;&#9;&#9;var txlast time.Time&#10;&#9;&#9;var balance string&#10;&#9;&#9;if err := rows.Scan(&amp;c.Address, &amp;c.Code, &amp;balance, &amp;isOpenInt, &amp;createtime, &amp;createBlockInt, &amp;txlast); err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;c.Balance = balance&#10;&#9;&#9;c.IsOpenSource = isOpenInt != 0&#10;&#9;&#9;c.CreateTime = createtime&#10;&#9;&#9;c.CreateBlock = uint64(createBlockInt)&#10;&#9;&#9;c.TxLast = txlast&#10;&#9;&#9;out = append(out, c)&#10;&#9;}&#10;&#9;if rows.Err() != nil {&#10;&#9;&#9;return nil, rows.Err()&#10;&#9;}&#10;&#9;return out, nil&#10;}&#10;" />
              <option name="updatedContent" value="package config&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;&quot;github.com/jackc/pgx/v5/pgxpool&quot;&#10;)&#10;&#10;// 全局连接池（可选使用）&#10;var DBPool *pgxpool.Pool&#10;&#10;// InitDB 初始化 pgx 连接池并 ping 验证&#10;func InitDB(dsn string) (*pgxpool.Pool, error) {&#10;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;InitDB: empty dsn&quot;)&#10;&#9;}&#10;&#9;ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)&#10;&#9;defer cancel()&#10;&#9;pool, err := pgxpool.New(ctx, dsn)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;InitDB: %w&quot;, err)&#10;&#9;}&#10;&#9;if err := pool.Ping(ctx); err != nil {&#10;&#9;&#9;pool.Close()&#10;&#9;&#9;return nil, fmt.Errorf(&quot;InitDB ping failed: %w&quot;, err)&#10;&#9;}&#10;&#9;DBPool = pool&#10;&#9;return pool, nil&#10;}&#10;&#10;// GetContracts 从 contracts 表读取记录，limit&lt;=0 表示不限制&#10;func GetContracts(ctx context.Context, pool *pgxpool.Pool, limit int) ([]internal.Contract, error) {&#10;&#9;if pool == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;GetContracts: pool is nil&quot;)&#10;&#9;}&#10;&#9;q := &quot;SELECT address, contract, balance, isopensource, createtime, createblock, txlast FROM contracts&quot;&#10;&#9;var rows pgxpool.Rows&#10;&#9;var err error&#10;&#9;if limit &gt; 0 {&#10;&#9;&#9;rows, err = pool.Query(ctx, q+&quot; LIMIT $1&quot;, limit)&#10;&#9;} else {&#10;&#9;&#9;rows, err = pool.Query(ctx, q)&#10;&#9;}&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer rows.Close()&#10;&#10;&#9;var out []internal.Contract&#10;&#9;for rows.Next() {&#10;&#9;&#9;var c internal.Contract&#10;&#9;&#9;var isOpenInt int&#10;&#9;&#9;var createBlockInt int64&#10;&#9;&#9;var createtime time.Time&#10;&#9;&#9;var txlast time.Time&#10;&#9;&#9;var balance string&#10;&#9;&#9;if err := rows.Scan(&amp;c.Address, &amp;c.Code, &amp;balance, &amp;isOpenInt, &amp;createtime, &amp;createBlockInt, &amp;txlast); err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;c.Balance = balance&#10;&#9;&#9;c.IsOpenSource = isOpenInt != 0&#10;&#9;&#9;c.CreateTime = createtime&#10;&#9;&#9;c.CreateBlock = uint64(createBlockInt)&#10;&#9;&#9;c.TxLast = txlast&#10;&#9;&#9;out = append(out, c)&#10;&#9;}&#10;&#9;if rows.Err() != nil {&#10;&#9;&#9;return nil, rows.Err()&#10;&#9;}&#10;&#9;return out, nil&#10;}&#10;&#10;// GetContractsByAddresses 根据地址数组批量查询（使用 ANY($1::text[])）&#10;func GetContractsByAddresses(ctx context.Context, pool *pgxpool.Pool, addresses []string) ([]internal.Contract, error) {&#10;&#9;if pool == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;GetContractsByAddresses: pool is nil&quot;)&#10;&#9;}&#10;&#9;if len(addresses) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;GetContractsByAddresses: addresses empty&quot;)&#10;&#9;}&#10;&#9;q := &quot;SELECT address, contract, balance, isopensource, createtime, createblock, txlast FROM contracts WHERE address = ANY($1::text[])&quot;&#10;&#9;rows, err := pool.Query(ctx, q, addresses)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#9;defer rows.Close()&#10;&#10;&#9;var out []internal.Contract&#10;&#9;for rows.Next() {&#10;&#9;&#9;var c internal.Contract&#10;&#9;&#9;var isOpenInt int&#10;&#9;&#9;var createBlockInt int64&#10;&#9;&#9;var createtime time.Time&#10;&#9;&#9;var txlast time.Time&#10;&#9;&#9;var balance string&#10;&#9;&#9;if err := rows.Scan(&amp;c.Address, &amp;c.Code, &amp;balance, &amp;isOpenInt, &amp;createtime, &amp;createBlockInt, &amp;txlast); err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;c.Balance = balance&#10;&#9;&#9;c.IsOpenSource = isOpenInt != 0&#10;&#9;&#9;c.CreateTime = createtime&#10;&#9;&#9;c.CreateBlock = uint64(createBlockInt)&#10;&#9;&#9;c.TxLast = txlast&#10;&#9;&#9;out = append(out, c)&#10;&#9;}&#10;&#9;if rows.Err() != nil {&#10;&#9;&#9;return nil, rows.Err()&#10;&#9;}&#10;&#9;return out, nil&#10;}&#10;&#10;// GetRPCURL 返回用于连接以太坊节点的 RPC URL。&#10;// 优先使用环境变量 RPC_URL；若未设置，则尝试读取常见路径下的 rpc.txt 文件（例如 ./src/config/rpc.txt 或 ./config/rpc.txt）。&#10;func GetRPCURL() (string, error) {&#10;&#9;// 优先环境变量&#10;&#9;if v := strings.TrimSpace(os.Getenv(&quot;RPC_URL&quot;)); v != &quot;&quot; {&#10;&#9;&#9;return v, nil&#10;&#9;}&#10;&#9;// 尝试读取文件&#10;&#9;paths := []string{&#10;&#9;&#9;&quot;./src/config/rpc.txt&quot;,&#10;&#9;&#9;&quot;./config/rpc.txt&quot;,&#10;&#9;&#9;&quot;./rpc.txt&quot;,&#10;&#9;}&#10;&#9;for _, p := range paths {&#10;&#9;&#9;b, err := os.ReadFile(p)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;if s := strings.TrimSpace(string(b)); s != &quot;&quot; {&#10;&#9;&#9;&#9;return s, nil&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return &quot;&quot;, fmt.Errorf(&quot;RPC_URL 未配置：请设置环境变量 RPC_URL 或在 src/config/rpc.txt 提供 RPC URL&quot;)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/ai/parser/parser.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/ai/parser/parser.go" />
              <option name="originalContent" value="package ai&#10;&#10;// Parser 全局占位对象&#10;var Parser = &amp;aiParser{}&#10;&#10;type aiParser struct{}&#10;&#10;// Parse 将原始 AI 输出转换为结构化 ScanResult&#10;func (p *aiParser) Parse(raw string) ([]ScanResult, error) {&#10;&#9;// TODO: 解析 AI 输出&#10;&#9;return []ScanResult{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;ContractAddress: &quot;0xDEADBEEF&quot;,&#10;&#9;&#9;&#9;Vulnerability:   &quot;MockVul&quot;,&#10;&#9;&#9;&#9;Severity:        &quot;High&quot;,&#10;&#9;&#9;&#9;Details:         raw,&#10;&#9;&#9;&#9;Line:            1,&#10;&#9;&#9;},&#10;&#9;}, nil&#10;}&#10;" />
              <option name="updatedContent" value="package parser&#10;&#10;// Parser 全局占位对象&#10;var Parser = &amp;aiParser{}&#10;&#10;type aiParser struct{}&#10;&#10;// Parse 将原始 AI 输出转换为结构化 ScanResult&#10;func (p *aiParser) Parse(raw string) ([]ScanResult, error) {&#10;&#9;// TODO: 解析 AI 输出&#10;&#9;return []ScanResult{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;ContractAddress: &quot;0xDEADBEEF&quot;,&#10;&#9;&#9;&#9;Vulnerability:   &quot;MockVul&quot;,&#10;&#9;&#9;&#9;Severity:        &quot;High&quot;,&#10;&#9;&#9;&#9;Details:         raw,&#10;&#9;&#9;&#9;Line:            1,&#10;&#9;&#9;},&#10;&#9;}, nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/ai/parser/schema.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/ai/parser/schema.go" />
              <option name="originalContent" value="package ai&#10;&#10;type ScanResult struct {&#10;&#9;ContractAddress string&#10;&#9;Vulnerability   string&#10;&#9;Severity        string&#10;&#9;Details         string&#10;&#9;Line            int&#10;}&#10;" />
              <option name="updatedContent" value="package parser&#10;&#10;type ScanResult struct {&#10;&#9;ContractAddress string&#10;&#9;Vulnerability   string&#10;&#9;Severity        string&#10;&#9;Details         string&#10;&#9;Line            int&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/core/mode1.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/core/mode1.go" />
              <option name="originalContent" value="package core&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/cmd&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/types&quot;&#10;)&#10;&#10;// Mode1Scan 扫描合约并返回原始 AI 输出（占位实现）&#10;func Mode1Scan(contract types.Contract, prompt string, expCode string, cfg *cmd.CLIConfig) (string, error) {&#10;&#9;// TODO: 实际扫描逻辑，例如调用 AI 或分析 EXP&#10;&#9;return fmt.Sprintf(&quot;Mock AI 输出 for %s&quot;, contract.Address), nil&#10;}&#10;" />
              <option name="updatedContent" value="package core&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;)&#10;&#10;// Mode1Scan 扫描合约并返回原始 AI 输出（占位实现）&#10;func Mode1Scan(contract internal.Contract, prompt string, expCode string, cfg internal.ScanConfig) (string, error) {&#10;&#9;// TODO: 实际扫描逻辑，例如调用 AI 或分析 EXP&#10;&#9;return fmt.Sprintf(&quot;Mock AI 输出 for %s&quot;, contract.Address), nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/download/download.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/download/download.go" />
              <option name="originalContent" value="package download&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;database/sql&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;math/big&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;net/url&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/config&quot;&#10;&#9;&quot;github.com/ethereum/go-ethereum/common&quot;&#10;&#9;&quot;github.com/ethereum/go-ethereum/ethclient&quot;&#10;)&#10;&#10;// ContractInfo 合约信息结构体&#10;type ContractInfo struct {&#10;&#9;Address      string&#10;&#9;Contract     string&#10;&#9;Balance      string&#10;&#9;IsOpenSource int&#10;&#9;CreateTime   time.Time&#10;&#9;CreateBlock  uint64&#10;&#9;TxLast       time.Time&#10;&#9;IsDecompiled int&#10;&#9;DedCode      string&#10;}&#10;&#10;// Downloader 下载器&#10;type Downloader struct {&#10;&#9;client          *ethclient.Client&#10;&#9;db              *sql.DB&#10;&#9;etherscanConfig EtherscanConfig&#10;&#9;rateLimiter     *RateLimiter&#10;}&#10;&#10;// NewDownloader 创建下载器（使用配置文件中的 RPC URL）&#10;// 新增 proxy 参数，若 proxy 非空，会设置全局 HTTP Transport 的代理并传入 etherscan 配置&#10;func NewDownloader(db *sql.DB, proxy string) (*Downloader, error) {&#10;&#9;if db == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;数据库连接不能为 nil&quot;)&#10;&#9;}&#10;&#10;&#9;// 如果传入 proxy，则设置全局默认 transport 的代理（影响 HTTP 客户端以及 ethclient 使用的默认 transport）&#10;&#9;if strings.TrimSpace(proxy) != &quot;&quot; {&#10;&#9;&#9;u, err := url.Parse(proxy)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;解析 proxy URL 失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;// 设置全局 DefaultTransport 为带 proxy 的 Transport（保留默认超时等其他字段可以按需调整）&#10;&#9;&#9;http.DefaultTransport = &amp;http.Transport{&#10;&#9;&#9;&#9;Proxy: http.ProxyURL(u),&#10;&#9;&#9;&#9;// 其它字段采用零值或按需设置（可根据需要添加 TLSHandshakeTimeout 等）&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 从配置文件获取 RPC URL&#10;&#9;rpcURL, err := config.GetRPCURL()&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;获取 RPC URL 失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 连接以太坊节点（使用默认 transport，若上面设置了 proxy，则会生效）&#10;&#9;client, err := ethclient.Dial(rpcURL)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;连接以太坊节点失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot;✅ 成功连接到以太坊节点: %s\n&quot;, rpcURL)&#10;&#10;&#9;// 初始化 etherscan 配置（从 config 常量读取），并注入 proxy&#10;&#9;ethersCfg := EtherscanConfig{&#10;&#9;&#9;APIKey:  config.EtherscanAPIKey,&#10;&#9;&#9;BaseURL: config.EtherscanBaseURL,&#10;&#9;&#9;Proxy:   strings.TrimSpace(proxy),&#10;&#9;}&#10;&#10;&#9;return &amp;Downloader{&#10;&#9;&#9;client:          client,&#10;&#9;&#9;db:              db,&#10;&#9;&#9;etherscanConfig: ethersCfg,&#10;&#9;&#9;rateLimiter:     NewRateLimiter(5), // 可调整速率&#10;&#9;}, nil&#10;}&#10;&#10;// GetCurrentBlock 获取当前最新区块号&#10;func (d *Downloader) GetCurrentBlock(ctx context.Context) (uint64, error) {&#10;&#9;return d.client.BlockNumber(ctx)&#10;}&#10;&#10;// GetLastDownloadedBlock 获取数据库中最后下载的区块号&#10;func (d *Downloader) GetLastDownloadedBlock(ctx context.Context) (uint64, error) {&#10;&#9;var maxBlock sql.NullInt64&#10;&#9;err := d.db.QueryRowContext(ctx, &quot;SELECT MAX(createblock) FROM contracts&quot;).Scan(&amp;maxBlock)&#10;&#9;if err != nil {&#10;&#9;&#9;return 0, fmt.Errorf(&quot;查询最后下载区块失败: %w&quot;, err)&#10;&#9;}&#10;&#9;if !maxBlock.Valid {&#10;&#9;&#9;return 0, nil&#10;&#9;}&#10;&#9;return uint64(maxBlock.Int64), nil&#10;}&#10;&#10;// ContractExists 检查合约是否已存在&#10;func (d *Downloader) ContractExists(ctx context.Context, address string) (bool, error) {&#10;&#9;var count int&#10;&#9;err := d.db.QueryRowContext(ctx, &quot;SELECT COUNT(*) FROM contracts WHERE address = ?&quot;, address).Scan(&amp;count)&#10;&#9;if err != nil {&#10;&#9;&#9;return false, err&#10;&#9;}&#10;&#9;return count &gt; 0, nil&#10;}&#10;&#10;// SaveContract 保存合约信息到数据库&#10;func (d *Downloader) SaveContract(ctx context.Context, info *ContractInfo) error {&#10;&#9;query := `&#10;&#9;INSERT INTO contracts (address, contract, balance, isopensource, createtime, createblock, txlast, isdecompiled, dedcode)&#10;&#9;VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)&#10;&#9;ON DUPLICATE KEY UPDATE &#10;&#9;&#9;contract = VALUES(contract),&#10;&#9;&#9;balance = VALUES(balance),&#10;&#9;&#9;isopensource = VALUES(isopensource),&#10;&#9;&#9;txlast = VALUES(txlast),&#10;&#9;&#9;isdecompiled = VALUES(isdecompiled),&#10;&#9;&#9;dedcode = VALUES(dedcode)&#10;&#9;`&#10;&#10;&#9;_, err := d.db.ExecContext(ctx, query,&#10;&#9;&#9;info.Address,&#10;&#9;&#9;info.Contract,&#10;&#9;&#9;info.Balance,&#10;&#9;&#9;info.IsOpenSource,&#10;&#9;&#9;info.CreateTime,&#10;&#9;&#9;int64(info.CreateBlock),&#10;&#9;&#9;info.TxLast,&#10;&#9;&#9;info.IsDecompiled,&#10;&#9;&#9;info.DedCode,&#10;&#9;)&#10;&#10;&#9;return err&#10;}&#10;&#10;// IsBlockDownloaded 检查区块是否已下载&#10;func (d *Downloader) IsBlockDownloaded(ctx context.Context, blockNum uint64) (bool, error) {&#10;&#9;var count int&#10;&#9;err := d.db.QueryRowContext(ctx, &quot;SELECT COUNT(*) FROM contracts WHERE createblock = ?&quot;, int64(blockNum)).Scan(&amp;count)&#10;&#9;if err != nil {&#10;&#9;&#9;return false, err&#10;&#9;}&#10;&#9;return count &gt; 0, nil&#10;}&#10;&#10;// helper: 将失败地址追加到文件（每行一个），忽略写入错误但记录日志&#10;func appendFailAddress(failFile, addr string) {&#10;&#9;if strings.TrimSpace(failFile) == &quot;&quot; || strings.TrimSpace(addr) == &quot;&quot; {&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;f, err := os.OpenFile(failFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0o644)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;⚠️  无法打开失败记录文件 %s: %v\n&quot;, failFile, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer f.Close()&#10;&#9;if _, err := f.WriteString(strings.TrimSpace(addr) + &quot;\n&quot;); err != nil {&#10;&#9;&#9;log.Printf(&quot;⚠️  无法写入失败记录文件 %s: %v\n&quot;, failFile, err)&#10;&#9;}&#10;}&#10;&#10;// DownloadBlockRange 下载指定区块范围的合约&#10;func (d *Downloader) DownloadBlockRange(ctx context.Context, startBlock, endBlock uint64) error {&#10;&#9;log.Printf(&quot; 开始下载区块 %d 到 %d...\n&quot;, startBlock, endBlock)&#10;&#10;&#9;totalContracts := 0&#10;&#9;skippedBlocks := 0&#10;&#10;&#9;for blockNum := startBlock; blockNum &lt;= endBlock; blockNum++ {&#10;&#9;&#9;// 检查区块是否已下载&#10;&#9;&#9;downloaded, err := d.IsBlockDownloaded(ctx, blockNum)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;⚠️  检查区块 %d 状态失败: %v\n&quot;, blockNum, err)&#10;&#9;&#9;} else if downloaded {&#10;&#9;&#9;&#9;skippedBlocks++&#10;&#9;&#9;&#9;if skippedBlocks%100 == 0 {&#10;&#9;&#9;&#9;&#9;log.Printf(&quot;⏭️  已跳过 %d 个已下载的区块...\n&quot;, skippedBlocks)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 获取区块数据&#10;&#9;&#9;block, err := d.client.BlockByNumber(ctx, big.NewInt(int64(blockNum)))&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;❌ 获取区块 %d 失败: %v\n&quot;, blockNum, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;txCount := len(block.Transactions())&#10;&#9;&#9;if txCount &gt; 0 {&#10;&#9;&#9;&#9;log.Printf(&quot; 处理区块 %d (共 %d 笔交易)...\n&quot;, blockNum, txCount)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;blockTime := time.Unix(int64(block.Time()), 0)&#10;&#9;&#9;contractCount := 0&#10;&#10;&#9;&#9;// 遍历交易查找合约创建&#10;&#9;&#9;for _, tx := range block.Transactions() {&#10;&#9;&#9;&#9;// 合约创建交易的 To 地址为 nil&#10;&#9;&#9;&#9;if tx.To() == nil {&#10;&#9;&#9;&#9;&#9;receipt, err := d.client.TransactionReceipt(ctx, tx.Hash())&#10;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;⚠️  获取交易收据失败: %v\n&quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;if receipt.ContractAddress != (common.Address{}) {&#10;&#9;&#9;&#9;&#9;&#9;contractAddr := receipt.ContractAddress.Hex()&#10;&#10;&#9;&#9;&#9;&#9;&#9;// 再次检查合约是否已存在&#10;&#9;&#9;&#9;&#9;&#9;exists, err := d.ContractExists(ctx, contractAddr)&#10;&#9;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;❌ 检查合约存在失败: %v\n&quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;if exists {&#10;&#9;&#9;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;// 获取合约字节码&#10;&#9;&#9;&#9;&#9;&#9;code, err := d.client.CodeAt(ctx, receipt.ContractAddress, nil)&#10;&#9;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;⚠️  获取合约代码失败: %v\n&quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;// 声明用于保存的变量，确保在所有分支都有初始值&#10;&#9;&#9;&#9;&#9;&#9;var contractCode string&#10;&#9;&#9;&#9;&#9;&#9;var isOpenSource int&#10;&#10;&#9;&#9;&#9;&#9;&#9;// 清理地址，去除可能的空格/换行/不可见字符，避免在 URL 拼接时出现问题&#10;&#9;&#9;&#9;&#9;&#9;contractAddr = strings.TrimSpace(contractAddr)&#10;&#10;&#9;&#9;&#9;&#9;&#9;// 检查 Etherscan 验证状态（若未配置 APIKey 则直接回退为字节码）&#10;&#9;&#9;&#9;&#9;&#9;if d.etherscanConfig.APIKey != &quot;&quot; {&#10;&#9;&#9;&#9;&#9;&#9;&#9;sourceCode, isVerified, err := GetContractSource(contractAddr, d.etherscanConfig)&#10;&#9;&#9;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 查询失败时回退为字节码并记录日志&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;⚠️  查询 Etherscan 失败: %v，回退保存字节码\n&quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;contractCode = fmt.Sprintf(&quot;0x%x&quot;, code)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;isOpenSource = 0&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 记录到失败文件&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;appendFailAddress(&quot;eoferror.txt&quot;, contractAddr)&#10;&#9;&#9;&#9;&#9;&#9;&#9;} else if isVerified {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;contractCode = sourceCode // 保存源代码&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;isOpenSource = 1          // 标记为已开源&#10;&#9;&#9;&#9;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;contractCode = fmt.Sprintf(&quot;0x%x&quot;, code) // 保存字节码&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;isOpenSource = 0                         // 标记为未开源&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;&#9;&#9;// 未配置 Etherscan API key，直接保存字节码&#10;&#9;&#9;&#9;&#9;&#9;&#9;contractCode = fmt.Sprintf(&quot;0x%x&quot;, code)&#10;&#9;&#9;&#9;&#9;&#9;&#9;isOpenSource = 0&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;// 获取合约余额&#10;&#9;&#9;&#9;&#9;&#9;balance, err := d.client.BalanceAt(ctx, receipt.ContractAddress, nil)&#10;&#9;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;⚠️  获取余额失败: %v\n&quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;&#9;balance = big.NewInt(0)&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;balanceEth := new(big.Float).Quo(&#10;&#9;&#9;&#9;&#9;&#9;&#9;new(big.Float).SetInt(balance),&#10;&#9;&#9;&#9;&#9;&#9;&#9;big.NewFloat(1e18),&#10;&#9;&#9;&#9;&#9;&#9;)&#10;&#10;&#9;&#9;&#9;&#9;&#9;// 构造合约信息（使用上面确定的 contractCode 与 isOpenSource）&#10;&#9;&#9;&#9;&#9;&#9;info := &amp;ContractInfo{&#10;&#9;&#9;&#9;&#9;&#9;&#9;Address:      contractAddr,&#10;&#9;&#9;&#9;&#9;&#9;&#9;Contract:     contractCode,&#10;&#9;&#9;&#9;&#9;&#9;&#9;Balance:      balanceEth.Text('f', 6),&#10;&#9;&#9;&#9;&#9;&#9;&#9;IsOpenSource: isOpenSource,&#10;&#9;&#9;&#9;&#9;&#9;&#9;CreateTime:   blockTime,&#10;&#9;&#9;&#9;&#9;&#9;&#9;CreateBlock:  blockNum,&#10;&#9;&#9;&#9;&#9;&#9;&#9;TxLast:       blockTime,&#10;&#9;&#9;&#9;&#9;&#9;&#9;IsDecompiled: 0,  // 默认未反编译&#10;&#9;&#9;&#9;&#9;&#9;&#9;DedCode:      &quot;&quot;, // 默认空&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;// 保存到数据库&#10;&#9;&#9;&#9;&#9;&#9;if err := d.SaveContract(ctx, info); err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;❌ 保存合约失败: %v\n&quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;contractCount++&#10;&#9;&#9;&#9;&#9;&#9;totalContracts++&#10;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;✅ 发现合约: %s (区块 %d)\n&quot;, contractAddr, blockNum)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 进度报告&#10;&#9;&#9;if blockNum%100 == 0 || contractCount &gt; 0 {&#10;&#9;&#9;&#9;progress := float64(blockNum-startBlock+1) / float64(endBlock-startBlock+1) * 100&#10;&#9;&#9;&#9;log.Printf(&quot; 进度: %.2f%% (区块 %d/%d, 累计合约: %d)\n&quot;,&#10;&#9;&#9;&#9;&#9;progress, blockNum, endBlock, totalContracts)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 避免请求过快&#10;&#9;&#9;time.Sleep(50 * time.Millisecond)&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot;\n✅ 下载完成!\n&quot;)&#10;&#9;log.Printf(&quot;   - 区块范围: %d - %d\n&quot;, startBlock, endBlock)&#10;&#9;log.Printf(&quot;   - 新增合约: %d\n&quot;, totalContracts)&#10;&#9;log.Printf(&quot;   - 跳过区块: %d\n&quot;, skippedBlocks)&#10;&#10;&#9;return nil&#10;}&#10;&#10;// DownloadFromLast 从最后下载的区块继续下载到最新区块&#10;func (d *Downloader) DownloadFromLast(ctx context.Context) error {&#10;&#9;// 获取最后下载的区块&#10;&#9;lastBlock, err := d.GetLastDownloadedBlock(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;获取最后下载区块失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 获取当前最新区块&#10;&#9;currentBlock, err := d.GetCurrentBlock(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;获取当前区块失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 如果没有下载记录,从创世区块开始&#10;&#9;startBlock := lastBlock + 1&#10;&#9;if lastBlock == 0 {&#10;&#9;&#9;startBlock = 0&#10;&#9;&#9;log.Println(&quot; 数据库为空,从创世区块开始下载&quot;)&#10;&#9;} else {&#10;&#9;&#9;log.Printf(&quot; 从区块 %d 继续下载 (上次: %d)\n&quot;, startBlock, lastBlock)&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot; 目标区块: %d (当前最新)\n&quot;, currentBlock)&#10;&#10;&#9;if startBlock &gt; currentBlock {&#10;&#9;&#9;log.Println(&quot;✅ 已经是最新,无需下载&quot;)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 开始下载&#10;&#9;return d.DownloadBlockRange(ctx, startBlock, currentBlock)&#10;}&#10;&#10;// Close 关闭连接&#10;func (d *Downloader) Close() {&#10;&#9;if d.client != nil {&#10;&#9;&#9;d.client.Close()&#10;&#9;}&#10;}&#10;&#10;// 新增：按地址列表下载合约（用于 -d -file &lt;file&gt; 重试）&#10;func (d *Downloader) DownloadContractsByAddresses(ctx context.Context, addresses []string, failLog string) error {&#10;&#9;if len(addresses) == 0 {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;seen := make(map[string]struct{})&#10;&#9;for _, a := range addresses {&#10;&#9;&#9;addr := strings.TrimSpace(a)&#10;&#9;&#9;if addr == &quot;&quot; {&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;// 去重&#10;&#9;&#9;if _, ok := seen[strings.ToLower(addr)]; ok {&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;seen[strings.ToLower(addr)] = struct{}{}&#10;&#10;&#9;&#9;// 检查是否已存在&#10;&#9;&#9;exists, err := d.ContractExists(ctx, addr)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;⚠️  检查合约 %s 是否存在失败: %v\n&quot;, addr, err)&#10;&#9;&#9;&#9;appendFailAddress(failLog, addr)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;if exists {&#10;&#9;&#9;&#9;log.Printf(&quot;⏭️  合约已存在，跳过: %s\n&quot;, addr)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 转换为 common.Address&#10;&#9;&#9;caddr := common.HexToAddress(addr)&#10;&#10;&#9;&#9;// 获取合约字节码&#10;&#9;&#9;code, err := d.client.CodeAt(ctx, caddr, nil)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;⚠️  获取合约字节码失败: %s -&gt; %v\n&quot;, addr, err)&#10;&#9;&#9;&#9;appendFailAddress(failLog, addr)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 默认值&#10;&#9;&#9;contractCode := fmt.Sprintf(&quot;0x%x&quot;, code)&#10;&#9;&#9;isOpenSource := 0&#10;&#10;&#9;&#9;// 如果配置了 Etherscan APIKey，尝试获取源码；网络错误时将地址写入失败文件&#10;&#9;&#9;if d.etherscanConfig.APIKey != &quot;&quot; {&#10;&#9;&#9;&#9;sourceCode, isVerified, err := GetContractSource(addr, d.etherscanConfig)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;log.Printf(&quot;⚠️  查询 Etherscan 失败 for %s: %v，回退保存字节码并记录到失败文件\n&quot;, addr, err)&#10;&#9;&#9;&#9;&#9;appendFailAddress(failLog, addr)&#10;&#9;&#9;&#9;&#9;// 回退保存字节码（contractCode 已为字节码）&#10;&#9;&#9;&#9;} else if isVerified {&#10;&#9;&#9;&#9;&#9;contractCode = sourceCode&#10;&#9;&#9;&#9;&#9;isOpenSource = 1&#10;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;// 未验证，保持字节码&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 获取余额（不阻塞主流程，失败则置零）&#10;&#9;&#9;balance, err := d.client.BalanceAt(ctx, caddr, nil)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;⚠️  获取余额失败: %s -&gt; %v\n&quot;, addr, err)&#10;&#9;&#9;&#9;balance = big.NewInt(0)&#10;&#9;&#9;}&#10;&#9;&#9;balanceEth := new(big.Float).Quo(new(big.Float).SetInt(balance), big.NewFloat(1e18))&#10;&#10;&#9;&#9;info := &amp;ContractInfo{&#10;&#9;&#9;&#9;Address:      addr,&#10;&#9;&#9;&#9;Contract:     contractCode,&#10;&#9;&#9;&#9;Balance:      balanceEth.Text('f', 6),&#10;&#9;&#9;&#9;IsOpenSource: isOpenSource,&#10;&#9;&#9;&#9;CreateTime:   time.Now(),&#10;&#9;&#9;&#9;CreateBlock:  0,&#10;&#9;&#9;&#9;TxLast:       time.Now(),&#10;&#9;&#9;&#9;IsDecompiled: 0,&#10;&#9;&#9;&#9;DedCode:      &quot;&quot;,&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 保存到数据库&#10;&#9;&#9;if err := d.SaveContract(ctx, info); err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;❌ 保存合约失败: %s -&gt; %v\n&quot;, addr, err)&#10;&#9;&#9;&#9;appendFailAddress(failLog, addr)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;log.Printf(&quot;✅ 重试下载合约成功: %s\n&quot;, addr)&#10;&#10;&#9;&#9;// 为了避免速率过快，可在此加入短暂停顿或使用 d.rateLimiter.Wait()&#10;&#9;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;" />
              <option name="updatedContent" value="package download&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;database/sql&quot;&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#9;&quot;math/big&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;net/url&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;sort&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/config&quot;&#10;&#9;&quot;github.com/ethereum/go-ethereum/common&quot;&#10;&#9;&quot;github.com/ethereum/go-ethereum/ethclient&quot;&#10;)&#10;&#10;// ContractInfo 合约信息结构体&#10;type ContractInfo struct {&#10;&#9;Address      string&#10;&#9;Contract     string&#10;&#9;Balance      string&#10;&#9;IsOpenSource int&#10;&#9;CreateTime   time.Time&#10;&#9;CreateBlock  uint64&#10;&#9;TxLast       time.Time&#10;&#9;IsDecompiled int&#10;&#9;DedCode      string&#10;}&#10;&#10;// Downloader 下载器&#10;type Downloader struct {&#10;&#9;client          *ethclient.Client&#10;&#9;db              *sql.DB&#10;&#9;etherscanConfig EtherscanConfig&#10;&#9;rateLimiter     *RateLimiter&#10;}&#10;&#10;// NewDownloader 创建下载器（使用配置文件中的 RPC URL）&#10;// 新增 proxy 参数，若 proxy 非空，会设置全局 HTTP Transport 的代理并传入 etherscan 配置&#10;func NewDownloader(db *sql.DB, proxy string) (*Downloader, error) {&#10;&#9;if db == nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;数据库连接不能为 nil&quot;)&#10;&#9;}&#10;&#10;&#9;// 如果传入 proxy，则设置全局默认 transport 的代理（影响 HTTP 客户端以及 ethclient 使用的默认 transport）&#10;&#9;if strings.TrimSpace(proxy) != &quot;&quot; {&#10;&#9;&#9;u, err := url.Parse(proxy)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;解析 proxy URL 失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;// 设置全局 DefaultTransport 为带 proxy 的 Transport（保留默认超时等其他字段可以按需调整）&#10;&#9;&#9;http.DefaultTransport = &amp;http.Transport{&#10;&#9;&#9;&#9;Proxy: http.ProxyURL(u),&#10;&#9;&#9;&#9;// 其它字段采用零值或按需设置（可根据需要添加 TLSHandshakeTimeout 等）&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 从配置文件获取 RPC URL&#10;&#9;rpcURL, err := config.GetRPCURL()&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;获取 RPC URL 失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 连接以太坊节点（使用默认 transport，若上面设置了 proxy，则会生效）&#10;&#9;client, err := ethclient.Dial(rpcURL)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;连接以太坊节点失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot;✅ 成功连接到以太坊节点: %s\n&quot;, rpcURL)&#10;&#10;&#9;// 初始化 etherscan 配置（从 config 常量读取），并注入 proxy&#10;&#9;ethersCfg := EtherscanConfig{&#10;&#9;&#9;APIKey:  config.EtherscanAPIKey,&#10;&#9;&#9;BaseURL: config.EtherscanBaseURL,&#10;&#9;&#9;Proxy:   strings.TrimSpace(proxy),&#10;&#9;}&#10;&#10;&#9;return &amp;Downloader{&#10;&#9;&#9;client:          client,&#10;&#9;&#9;db:              db,&#10;&#9;&#9;etherscanConfig: ethersCfg,&#10;&#9;&#9;rateLimiter:     NewRateLimiter(5), // 可调整速率&#10;&#9;}, nil&#10;}&#10;&#10;// GetCurrentBlock 获取当前最新区块号&#10;func (d *Downloader) GetCurrentBlock(ctx context.Context) (uint64, error) {&#10;&#9;return d.client.BlockNumber(ctx)&#10;}&#10;&#10;// GetLastDownloadedBlock 获取数据库中最后下载的区块号&#10;func (d *Downloader) GetLastDownloadedBlock(ctx context.Context) (uint64, error) {&#10;&#9;var maxBlock sql.NullInt64&#10;&#9;err := d.db.QueryRowContext(ctx, &quot;SELECT MAX(createblock) FROM contracts&quot;).Scan(&amp;maxBlock)&#10;&#9;if err != nil {&#10;&#9;&#9;return 0, fmt.Errorf(&quot;查询最后下载区块失败: %w&quot;, err)&#10;&#9;}&#10;&#9;if !maxBlock.Valid {&#10;&#9;&#9;return 0, nil&#10;&#9;}&#10;&#9;return uint64(maxBlock.Int64), nil&#10;}&#10;&#10;// ContractExists 检查合约是否已存在&#10;func (d *Downloader) ContractExists(ctx context.Context, address string) (bool, error) {&#10;&#9;var count int&#10;&#9;err := d.db.QueryRowContext(ctx, &quot;SELECT COUNT(*) FROM contracts WHERE address = ?&quot;, address).Scan(&amp;count)&#10;&#9;if err != nil {&#10;&#9;&#9;return false, err&#10;&#9;}&#10;&#9;return count &gt; 0, nil&#10;}&#10;&#10;// SaveContract 保存合约信息到数据库&#10;func (d *Downloader) SaveContract(ctx context.Context, info *ContractInfo) error {&#10;&#9;query := `&#10;&#9;INSERT INTO contracts (address, contract, balance, isopensource, createtime, createblock, txlast, isdecompiled, dedcode)&#10;&#9;VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)&#10;&#9;ON DUPLICATE KEY UPDATE &#10;&#9;&#9;contract = VALUES(contract),&#10;&#9;&#9;balance = VALUES(balance),&#10;&#9;&#9;isopensource = VALUES(isopensource),&#10;&#9;&#9;txlast = VALUES(txlast),&#10;&#9;&#9;isdecompiled = VALUES(isdecompiled),&#10;&#9;&#9;dedcode = VALUES(dedcode)&#10;&#9;`&#10;&#10;&#9;_, err := d.db.ExecContext(ctx, query,&#10;&#9;&#9;info.Address,&#10;&#9;&#9;info.Contract,&#10;&#9;&#9;info.Balance,&#10;&#9;&#9;info.IsOpenSource,&#10;&#9;&#9;info.CreateTime,&#10;&#9;&#9;int64(info.CreateBlock),&#10;&#9;&#9;info.TxLast,&#10;&#9;&#9;info.IsDecompiled,&#10;&#9;&#9;info.DedCode,&#10;&#9;)&#10;&#10;&#9;return err&#10;}&#10;&#10;// IsBlockDownloaded 检查区块是否已下载&#10;func (d *Downloader) IsBlockDownloaded(ctx context.Context, blockNum uint64) (bool, error) {&#10;&#9;var count int&#10;&#9;err := d.db.QueryRowContext(ctx, &quot;SELECT COUNT(*) FROM contracts WHERE createblock = ?&quot;, int64(blockNum)).Scan(&amp;count)&#10;&#9;if err != nil {&#10;&#9;&#9;return false, err&#10;&#9;}&#10;&#9;return count &gt; 0, nil&#10;}&#10;&#10;// helper: 将失败地址追加到文件（每行一个），忽略写入错误但记录日志&#10;func appendFailAddress(failFile, addr string) {&#10;&#9;if strings.TrimSpace(failFile) == &quot;&quot; || strings.TrimSpace(addr) == &quot;&quot; {&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;f, err := os.OpenFile(failFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0o644)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;⚠️  无法打开失败记录文件 %s: %v\n&quot;, failFile, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;defer f.Close()&#10;&#9;if _, err := f.WriteString(strings.TrimSpace(addr) + &quot;\n&quot;); err != nil {&#10;&#9;&#9;log.Printf(&quot;⚠️  无法写入失败记录文件 %s: %v\n&quot;, failFile, err)&#10;&#9;}&#10;}&#10;&#10;// 新增：记录已下载区块区间的结构与文件路径&#10;type BlockRangeRecord struct {&#10;&#9;Start uint64 `json:&quot;start&quot;`&#10;&#9;End   uint64 `json:&quot;end&quot;`&#10;}&#10;&#10;const blockedFile = &quot;blocked.json&quot; // 可修改为其他路径&#10;&#10;// loadBlockedRanges 从 blocked.json 读取已下载区间（若文件不存在，返回空切片）&#10;func loadBlockedRanges() ([]BlockRangeRecord, error) {&#10;&#9;bs, err := os.ReadFile(blockedFile)&#10;&#9;if err != nil {&#10;&#9;&#9;if os.IsNotExist(err) {&#10;&#9;&#9;&#9;return nil, nil&#10;&#9;&#9;}&#10;&#9;&#9;return nil, fmt.Errorf(&quot;读取 %s 失败: %w&quot;, blockedFile, err)&#10;&#9;}&#10;&#9;var recs []BlockRangeRecord&#10;&#9;if err := json.Unmarshal(bs, &amp;recs); err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;解析 %s 失败: %w&quot;, blockedFile, err)&#10;&#9;}&#10;&#9;return recs, nil&#10;}&#10;&#10;// saveBlockedRanges 将合并后的区间写回 blocked.json&#10;func saveBlockedRanges(recs []BlockRangeRecord) error {&#10;&#9;bs, err := json.MarshalIndent(recs, &quot;&quot;, &quot;  &quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;序列化 blocked ranges 失败: %w&quot;, err)&#10;&#9;}&#10;&#9;if err := os.WriteFile(blockedFile, bs, 0o644); err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;写入 %s 失败: %w&quot;, blockedFile, err)&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// mergeAndInsertRange 将 newRange 并入 existing 并返回合并后的区间列表（按 start 排序且不重叠）&#10;func mergeAndInsertRange(existing []BlockRangeRecord, newRange BlockRangeRecord) []BlockRangeRecord {&#10;&#9;existing = append(existing, newRange)&#10;&#9;if len(existing) == 0 {&#10;&#9;&#9;return existing&#10;&#9;}&#10;&#9;// 按 Start 排序&#10;&#9;sort.Slice(existing, func(i, j int) bool {&#10;&#9;&#9;return existing[i].Start &lt; existing[j].Start&#10;&#9;})&#10;&#9;merged := make([]BlockRangeRecord, 0, len(existing))&#10;&#9;curr := existing[0]&#10;&#9;for i := 1; i &lt; len(existing); i++ {&#10;&#9;&#9;r := existing[i]&#10;&#9;&#9;if r.Start &lt;= curr.End+1 { // 重叠或相邻 -&gt; 合并&#10;&#9;&#9;&#9;if r.End &gt; curr.End {&#10;&#9;&#9;&#9;&#9;curr.End = r.End&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;merged = append(merged, curr)&#10;&#9;&#9;&#9;curr = r&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;merged = append(merged, curr)&#10;&#9;return merged&#10;}&#10;&#10;// getUncoveredRanges 返回请求区间 requestRange 在 existingRanges 中未覆盖的子区间列表（按升序）&#10;func getUncoveredRanges(existingRanges []BlockRangeRecord, requestStart, requestEnd uint64) []BlockRangeRecord {&#10;&#9;if requestStart &gt; requestEnd {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#9;// 无已存在区间，直接返回请求区间&#10;&#9;if len(existingRanges) == 0 {&#10;&#9;&#9;return []BlockRangeRecord{{Start: requestStart, End: requestEnd}}&#10;&#9;}&#10;&#9;// 先合并 existingRanges 以简化计算&#10;&#9;sort.Slice(existingRanges, func(i, j int) bool { return existingRanges[i].Start &lt; existingRanges[j].Start })&#10;&#9;merged := []BlockRangeRecord{}&#10;&#9;curr := existingRanges[0]&#10;&#9;for i := 1; i &lt; len(existingRanges); i++ {&#10;&#9;&#9;r := existingRanges[i]&#10;&#9;&#9;if r.Start &lt;= curr.End+1 {&#10;&#9;&#9;&#9;if r.End &gt; curr.End {&#10;&#9;&#9;&#9;&#9;curr.End = r.End&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;merged = append(merged, curr)&#10;&#9;&#9;&#9;curr = r&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;merged = append(merged, curr)&#10;&#10;&#9;var out []BlockRangeRecord&#10;&#9;cursor := requestStart&#10;&#9;for _, r := range merged {&#10;&#9;&#9;// 如果当前已合并区间在请求区间左侧且不重叠，跳过&#10;&#9;&#9;if r.End &lt; cursor {&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;// 如果合并区间开始在请求结束之后，剩余整个区间都是未覆盖&#10;&#9;&#9;if r.Start &gt; requestEnd {&#10;&#9;&#9;&#9;break&#10;&#9;&#9;}&#10;&#9;&#9;// 有未覆盖段&#10;&#9;&#9;if r.Start &gt; cursor {&#10;&#9;&#9;&#9;end := minUint64(r.Start-1, requestEnd)&#10;&#9;&#9;&#9;if cursor &lt;= end {&#10;&#9;&#9;&#9;&#9;out = append(out, BlockRangeRecord{Start: cursor, End: end})&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;// 推进 cursor 到合并区间之后&#10;&#9;&#9;if r.End+1 &gt; cursor {&#10;&#9;&#9;&#9;cursor = r.End + 1&#10;&#9;&#9;}&#10;&#9;&#9;if cursor &gt; requestEnd {&#10;&#9;&#9;&#9;break&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;// 剩下的尾部&#10;&#9;if cursor &lt;= requestEnd {&#10;&#9;&#9;out = append(out, BlockRangeRecord{Start: cursor, End: requestEnd})&#10;&#9;}&#10;&#9;return out&#10;}&#10;&#10;func minUint64(a, b uint64) uint64 {&#10;&#9;if a &lt; b {&#10;&#9;&#9;return a&#10;&#9;}&#10;&#9;return b&#10;}&#10;&#10;// DownloadBlockRange 下载指定区块范围的合约（改为按未覆盖子区间下载并记录 blocked.json）&#10;func (d *Downloader) DownloadBlockRange(ctx context.Context, startBlock, endBlock uint64) error {&#10;&#9;log.Printf(&quot; 开始下载区块 %d 到 %d...\n&quot;, startBlock, endBlock)&#10;&#10;&#9;// 读取已下载区间记录&#10;&#9;existing, err := loadBlockedRanges()&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;⚠️  读取已下载区间失败: %v（继续，但可能重复下载）\n&quot;, err)&#10;&#9;&#9;// 继续使用 empty existing&#10;&#9;&#9;existing = nil&#10;&#9;}&#10;&#10;&#9;uncovered := getUncoveredRanges(existing, startBlock, endBlock)&#10;&#9;if len(uncovered) == 0 {&#10;&#9;&#9;log.Printf(&quot;✅ 请求区间 [%d-%d] 已全部下载，跳过\n&quot;, startBlock, endBlock)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;totalContracts := 0&#10;&#9;skippedBlocks := 0&#10;&#10;&#9;// 对每个未覆盖的子区间依次下载，子区间完成后合并写入 blocked.json&#10;&#9;for _, sub := range uncovered {&#10;&#9;&#9;log.Printf(&quot; 处理未覆盖子区间: %d - %d\n&quot;, sub.Start, sub.End)&#10;&#9;&#9;for blockNum := sub.Start; blockNum &lt;= sub.End; blockNum++ {&#10;&#9;&#9;&#9;// 检查区块是否已在数据库（谨慎双重判断）&#10;&#9;&#9;&#9;downloaded, err := d.IsBlockDownloaded(ctx, blockNum)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;log.Printf(&quot;⚠️  检查区块 %d 状态失败: %v\n&quot;, blockNum, err)&#10;&#9;&#9;&#9;} else if downloaded {&#10;&#9;&#9;&#9;&#9;skippedBlocks++&#10;&#9;&#9;&#9;&#9;if skippedBlocks%100 == 0 {&#10;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;⏭️  已跳过 %d 个已下载的区块...\n&quot;, skippedBlocks)&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;// 获取区块数据&#10;&#9;&#9;&#9;block, err := d.client.BlockByNumber(ctx, big.NewInt(int64(blockNum)))&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;log.Printf(&quot;❌ 获取区块 %d 失败: %v\n&quot;, blockNum, err)&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;txCount := len(block.Transactions())&#10;&#9;&#9;&#9;if txCount &gt; 0 {&#10;&#9;&#9;&#9;&#9;log.Printf(&quot; 处理区块 %d (共 %d 笔交易)...\n&quot;, blockNum, txCount)&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;blockTime := time.Unix(int64(block.Time()), 0)&#10;&#9;&#9;&#9;contractCount := 0&#10;&#10;&#9;&#9;&#9;// 遍历交易查找合约创建&#10;&#9;&#9;&#9;for _, tx := range block.Transactions() {&#10;&#9;&#9;&#9;&#9;// 合约创建交易的 To 地址为 nil&#10;&#9;&#9;&#9;&#9;if tx.To() == nil {&#10;&#9;&#9;&#9;&#9;&#9;receipt, err := d.client.TransactionReceipt(ctx, tx.Hash())&#10;&#9;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;⚠️  获取交易收据失败: %v\n&quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;if receipt.ContractAddress != (common.Address{}) {&#10;&#9;&#9;&#9;&#9;&#9;&#9;contractAddr := receipt.ContractAddress.Hex()&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// 再次检查合约是否已存在&#10;&#9;&#9;&#9;&#9;&#9;&#9;exists, err := d.ContractExists(ctx, contractAddr)&#10;&#9;&#9;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;❌ 检查合约存在失败: %v\n&quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;if exists {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// 获取合约字节码&#10;&#9;&#9;&#9;&#9;&#9;&#9;code, err := d.client.CodeAt(ctx, receipt.ContractAddress, nil)&#10;&#9;&#9;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;⚠️  获取合约代码失败: %v\n&quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// 声明用于保存的变量，确保在所有分支都有初始值&#10;&#9;&#9;&#9;&#9;&#9;&#9;var contractCode string&#10;&#9;&#9;&#9;&#9;&#9;&#9;var isOpenSource int&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// 清理地址，去除可能的空格/换行/不可见字符，避免在 URL 拼接时出现问题&#10;&#9;&#9;&#9;&#9;&#9;&#9;contractAddr = strings.TrimSpace(contractAddr)&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// 检查 Etherscan 验证状态（若未配置 APIKey 则直接回退为字节码）&#10;&#9;&#9;&#9;&#9;&#9;&#9;if d.etherscanConfig.APIKey != &quot;&quot; {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;sourceCode, isVerified, err := GetContractSource(contractAddr, d.etherscanConfig)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 查询失败时回退为字节码并记录日志&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;⚠️  查询 Etherscan 失败: %v，回退保存字节码\n&quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;contractCode = fmt.Sprintf(&quot;0x%x&quot;, code)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;isOpenSource = 0&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 记录到失败文件&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;appendFailAddress(&quot;eoferror.txt&quot;, contractAddr)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;} else if isVerified {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;contractCode = sourceCode // 保存源代码&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;isOpenSource = 1          // 标记为已开源&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;contractCode = fmt.Sprintf(&quot;0x%x&quot;, code) // 保存字节码&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;isOpenSource = 0                         // 标记为未开源&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;// 未配置 Etherscan API key，直接保存字节码&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;contractCode = fmt.Sprintf(&quot;0x%x&quot;, code)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;isOpenSource = 0&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// 获取合约余额&#10;&#9;&#9;&#9;&#9;&#9;&#9;balance, err := d.client.BalanceAt(ctx, receipt.ContractAddress, nil)&#10;&#9;&#9;&#9;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;⚠️  获取余额失败: %v\n&quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;balance = big.NewInt(0)&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;balanceEth := new(big.Float).Quo(&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;new(big.Float).SetInt(balance),&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;big.NewFloat(1e18),&#10;&#9;&#9;&#9;&#9;&#9;&#9;)&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// 构造合约信息（使用上面确定的 contractCode 与 isOpenSource）&#10;&#9;&#9;&#9;&#9;&#9;&#9;info := &amp;ContractInfo{&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Address:      contractAddr,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Contract:     contractCode,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Balance:      balanceEth.Text('f', 6),&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;IsOpenSource: isOpenSource,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;CreateTime:   blockTime,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;CreateBlock:  blockNum,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;TxLast:       blockTime,&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;IsDecompiled: 0,  // 默认未反编译&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;DedCode:      &quot;&quot;, // 默认空&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;// 保存到数据库&#10;&#9;&#9;&#9;&#9;&#9;&#9;if err := d.SaveContract(ctx, info); err != nil {&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;❌ 保存合约失败: %v\n&quot;, err)&#10;&#9;&#9;&#9;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;&#9;&#9;&#9;contractCount++&#10;&#9;&#9;&#9;&#9;&#9;&#9;totalContracts++&#10;&#9;&#9;&#9;&#9;&#9;&#9;log.Printf(&quot;✅ 发现合约: %s (区块 %d)\n&quot;, contractAddr, blockNum)&#10;&#9;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;// 避免请求过快&#10;&#9;&#9;&#9;time.Sleep(50 * time.Millisecond)&#10;&#9;&#9;} // end for blockNum in subrange&#10;&#10;&#9;&#9;// 子区间完成后，将其合并写入 blocked.json&#10;&#9;&#9;merged := mergeAndInsertRange(existing, BlockRangeRecord{Start: sub.Start, End: sub.End})&#10;&#9;&#9;if err := saveBlockedRanges(merged); err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;⚠️  保存已下载区间到 %s 失败: %v\n&quot;, blockedFile, err)&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;// 更新内存 existing 为最新（避免下一个子区间重复计算）&#10;&#9;&#9;&#9;existing = merged&#10;&#9;&#9;}&#10;&#9;} // end for each sub&#10;&#10;&#9;log.Printf(&quot;\n✅ 下载完成!\n&quot;)&#10;&#9;log.Printf(&quot;   - 区块范围: %d - %d\n&quot;, startBlock, endBlock)&#10;&#9;log.Printf(&quot;   - 新增合约: %d\n&quot;, totalContracts)&#10;&#9;log.Printf(&quot;   - 跳过区块: %d\n&quot;, skippedBlocks)&#10;&#10;&#9;return nil&#10;}&#10;&#10;// DownloadFromLast 从最后下载的区块继续下载到最新区块&#10;func (d *Downloader) DownloadFromLast(ctx context.Context) error {&#10;&#9;// 获取最后下载的区块&#10;&#9;lastBlock, err := d.GetLastDownloadedBlock(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;获取最后下载区块失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 获取当前最新区块&#10;&#9;currentBlock, err := d.GetCurrentBlock(ctx)&#10;&#9;if err != nil {&#10;&#9;&#9;return fmt.Errorf(&quot;获取当前区块失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 如果没有下载记录,从创世区块开始&#10;&#9;startBlock := lastBlock + 1&#10;&#9;if lastBlock == 0 {&#10;&#9;&#9;startBlock = 0&#10;&#9;&#9;log.Println(&quot; 数据库为空,从创世区块开始下载&quot;)&#10;&#9;} else {&#10;&#9;&#9;log.Printf(&quot; 从区块 %d 继续下载 (上次: %d)\n&quot;, startBlock, lastBlock)&#10;&#9;}&#10;&#10;&#9;log.Printf(&quot; 目标区块: %d (当前最新)\n&quot;, currentBlock)&#10;&#10;&#9;if startBlock &gt; currentBlock {&#10;&#9;&#9;log.Println(&quot;✅ 已经是最新,无需下载&quot;)&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;// 开始下载&#10;&#9;return d.DownloadBlockRange(ctx, startBlock, currentBlock)&#10;}&#10;&#10;// Close 关闭连接&#10;func (d *Downloader) Close() {&#10;&#9;if d.client != nil {&#10;&#9;&#9;d.client.Close()&#10;&#9;}&#10;}&#10;&#10;// 新增：按地址列表下载合约（用于 -d -file &lt;file&gt; 重试）&#10;func (d *Downloader) DownloadContractsByAddresses(ctx context.Context, addresses []string, failLog string) error {&#10;&#9;if len(addresses) == 0 {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;seen := make(map[string]struct{})&#10;&#9;for _, a := range addresses {&#10;&#9;&#9;addr := strings.TrimSpace(a)&#10;&#9;&#9;if addr == &quot;&quot; {&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;// 去重&#10;&#9;&#9;if _, ok := seen[strings.ToLower(addr)]; ok {&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;seen[strings.ToLower(addr)] = struct{}{}&#10;&#10;&#9;&#9;// 检查是否已存在&#10;&#9;&#9;exists, err := d.ContractExists(ctx, addr)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;⚠️  检查合约 %s 是否存在失败: %v\n&quot;, addr, err)&#10;&#9;&#9;&#9;appendFailAddress(failLog, addr)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#9;&#9;if exists {&#10;&#9;&#9;&#9;log.Printf(&quot;⏭️  合约已存在，跳过: %s\n&quot;, addr)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 转换为 common.Address&#10;&#9;&#9;caddr := common.HexToAddress(addr)&#10;&#10;&#9;&#9;// 获取合约字节码&#10;&#9;&#9;code, err := d.client.CodeAt(ctx, caddr, nil)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;⚠️  获取合约字节码失败: %s -&gt; %v\n&quot;, addr, err)&#10;&#9;&#9;&#9;appendFailAddress(failLog, addr)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 默认值&#10;&#9;&#9;contractCode := fmt.Sprintf(&quot;0x%x&quot;, code)&#10;&#9;&#9;isOpenSource := 0&#10;&#10;&#9;&#9;// 如果配置了 Etherscan APIKey，尝试获取源码；网络错误时将地址写入失败文件&#10;&#9;&#9;if d.etherscanConfig.APIKey != &quot;&quot; {&#10;&#9;&#9;&#9;sourceCode, isVerified, err := GetContractSource(addr, d.etherscanConfig)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;log.Printf(&quot;⚠️  查询 Etherscan 失败 for %s: %v，回退保存字节码并记录到失败文件\n&quot;, addr, err)&#10;&#9;&#9;&#9;&#9;appendFailAddress(failLog, addr)&#10;&#9;&#9;&#9;&#9;// 回退保存字节码（contractCode 已为字节码）&#10;&#9;&#9;&#9;} else if isVerified {&#10;&#9;&#9;&#9;&#9;contractCode = sourceCode&#10;&#9;&#9;&#9;&#9;isOpenSource = 1&#10;&#9;&#9;&#9;} else {&#10;&#9;&#9;&#9;&#9;// 未验证，保持字节码&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 获取余额（不阻塞主流程，失败则置零）&#10;&#9;&#9;balance, err := d.client.BalanceAt(ctx, caddr, nil)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;⚠️  获取余额失败: %s -&gt; %v\n&quot;, addr, err)&#10;&#9;&#9;&#9;balance = big.NewInt(0)&#10;&#9;&#9;}&#10;&#9;&#9;balanceEth := new(big.Float).Quo(new(big.Float).SetInt(balance), big.NewFloat(1e18))&#10;&#10;&#9;&#9;info := &amp;ContractInfo{&#10;&#9;&#9;&#9;Address:      addr,&#10;&#9;&#9;&#9;Contract:     contractCode,&#10;&#9;&#9;&#9;Balance:      balanceEth.Text('f', 6),&#10;&#9;&#9;&#9;IsOpenSource: isOpenSource,&#10;&#9;&#9;&#9;CreateTime:   time.Now(),&#10;&#9;&#9;&#9;CreateBlock:  0,&#10;&#9;&#9;&#9;TxLast:       time.Now(),&#10;&#9;&#9;&#9;IsDecompiled: 0,&#10;&#9;&#9;&#9;DedCode:      &quot;&quot;,&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 保存到数据库&#10;&#9;&#9;if err := d.SaveContract(ctx, info); err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;❌ 保存合约失败: %s -&gt; %v\n&quot;, addr, err)&#10;&#9;&#9;&#9;appendFailAddress(failLog, addr)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;log.Printf(&quot;✅ 重试下载合约成功: %s\n&quot;, addr)&#10;&#10;&#9;&#9;// 为了避免速率过快，可在此加入短暂停顿或使用 d.rateLimiter.Wait()&#10;&#9;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/download/etherscan_helper.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/download/etherscan_helper.go" />
              <option name="originalContent" value="package download&#10;&#10;import (&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;net/url&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// EtherscanConfig Etherscan API 配置&#10;type EtherscanConfig struct {&#10;&#9;APIKey  string&#10;&#9;BaseURL string&#10;&#9;Proxy   string // 新增：可选的 HTTP 代理 URL（例如 http://127.0.0.1:7897）&#10;}&#10;&#10;// EtherscanResponse Etherscan API 响应结构&#10;type EtherscanResponse struct {&#10;&#9;Status  string `json:&quot;status&quot;`&#10;&#9;Message string `json:&quot;message&quot;`&#10;&#9;Result  []struct {&#10;&#9;&#9;SourceCode           string `json:&quot;SourceCode&quot;`&#10;&#9;&#9;ABI                  string `json:&quot;ABI&quot;`&#10;&#9;&#9;ContractName         string `json:&quot;ContractName&quot;`&#10;&#9;&#9;CompilerVersion      string `json:&quot;CompilerVersion&quot;`&#10;&#9;&#9;OptimizationUsed     string `json:&quot;OptimizationUsed&quot;`&#10;&#9;&#9;Runs                 string `json:&quot;Runs&quot;`&#10;&#9;&#9;ConstructorArguments string `json:&quot;ConstructorArguments&quot;`&#10;&#9;&#9;EVMVersion           string `json:&quot;EVMVersion&quot;`&#10;&#9;&#9;Library              string `json:&quot;Library&quot;`&#10;&#9;&#9;LicenseType          string `json:&quot;LicenseType&quot;`&#10;&#9;&#9;Proxy                string `json:&quot;Proxy&quot;`&#10;&#9;&#9;Implementation       string `json:&quot;Implementation&quot;`&#10;&#9;&#9;SwarmSource          string `json:&quot;SwarmSource&quot;`&#10;&#9;} `json:&quot;result&quot;`&#10;}&#10;&#10;// GetContractSource 从 Etherscan 获取合约源代码和验证状态&#10;func GetContractSource(address string, config EtherscanConfig) (sourceCode string, isVerified bool, err error) {&#10;&#9;// 确保地址已清理&#10;&#9;address = strings.TrimSpace(address)&#10;&#9;if address == &quot;&quot; {&#10;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;空的地址传入 GetContractSource&quot;)&#10;&#9;}&#10;&#10;&#9;// 构建 API URL 使用 url.Values 避免拼接错误&#10;&#9;base := strings.TrimRight(config.BaseURL, &quot;/&quot;)&#10;&#9;u, err := url.Parse(base)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;解析 Etherscan BaseURL 失败: %w&quot;, err)&#10;&#9;}&#10;&#9;// 确保 path 指向 /api（兼容常见 Etherscan 路径）&#10;&#9;u.Path = strings.TrimRight(u.Path, &quot;/&quot;) + &quot;/api&quot;&#10;&#10;&#9;q := url.Values{}&#10;&#9;q.Set(&quot;module&quot;, &quot;contract&quot;)&#10;&#9;q.Set(&quot;action&quot;, &quot;getsourcecode&quot;)&#10;&#9;q.Set(&quot;address&quot;, address)&#10;&#9;q.Set(&quot;apikey&quot;, config.APIKey)&#10;&#9;// 若需要 chainid 可作为可选参数（保留原有 chainid=1）&#10;&#9;q.Set(&quot;chainid&quot;, &quot;1&quot;)&#10;&#10;&#9;u.RawQuery = q.Encode()&#10;&#9;finalURL := u.String()&#10;&#10;&#9;// 创建 HTTP 客户端（设置超时）&#10;&#9;client := &amp;http.Client{&#10;&#9;&#9;Timeout: 15 * time.Second, // 将超时增加到 15s，减少偶发超时&#10;&#9;}&#10;&#10;&#9;// 如果配置了代理，则为该客户端设置 Transport 的 Proxy&#10;&#9;if strings.TrimSpace(config.Proxy) != &quot;&quot; {&#10;&#9;&#9;if pu, err := url.Parse(config.Proxy); err == nil {&#10;&#9;&#9;&#9;client.Transport = &amp;http.Transport{&#10;&#9;&#9;&#9;&#9;Proxy: http.ProxyURL(pu),&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;// 解析代理失败也不要阻塞整体流程，记录为 warning 风格错误返回&#10;&#9;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;解析 Etherscan proxy 失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 发送请求&#10;&#9;resp, err := client.Get(finalURL)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;请求 Etherscan API 失败: %w (url=%s)&quot;, err, finalURL)&#10;&#9;}&#10;&#9;defer resp.Body.Close()&#10;&#10;&#9;// 检查 HTTP 状态码&#10;&#9;if resp.StatusCode != http.StatusOK {&#10;&#9;&#9;bodySnippet, _ := io.ReadAll(io.LimitReader(resp.Body, 1024))&#10;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;Etherscan 返回非 200 状态: %d, body: %s&quot;, resp.StatusCode, string(bodySnippet))&#10;&#9;}&#10;&#10;&#9;// 读取响应&#10;&#9;body, err := io.ReadAll(resp.Body)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;读取响应失败: %w&quot;, err)&#10;&#9;}&#10;&#10;&#9;// 解析 JSON&#10;&#9;var etherscanResp EtherscanResponse&#10;&#9;if err := json.Unmarshal(body, &amp;etherscanResp); err != nil {&#10;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;解析 JSON 失败: %w (url=%s)&quot;, err, finalURL)&#10;&#9;}&#10;&#10;&#9;// 检查 API 响应状态&#10;&#9;if etherscanResp.Status != &quot;1&quot; {&#10;&#9;&#9;// Status 不为 1 表示请求失败或合约未验证&#10;&#9;&#9;return &quot;&quot;, false, nil&#10;&#9;}&#10;&#10;&#9;// 检查结果&#10;&#9;if len(etherscanResp.Result) == 0 {&#10;&#9;&#9;return &quot;&quot;, false, nil&#10;&#9;}&#10;&#10;&#9;result := etherscanResp.Result[0]&#10;&#10;&#9;// 如果 SourceCode 为空，说明未验证&#10;&#9;if result.SourceCode == &quot;&quot; {&#10;&#9;&#9;return &quot;&quot;, false, nil&#10;&#9;}&#10;&#10;&#9;// 合约已验证&#10;&#9;return result.SourceCode, true, nil&#10;}&#10;&#10;// RateLimiter 简单的速率限制器&#10;type RateLimiter struct {&#10;&#9;ticker *time.Ticker&#10;}&#10;&#10;// NewRateLimiter 创建速率限制器（每秒最多 requestsPerSecond 个请求）&#10;func NewRateLimiter(requestsPerSecond int) *RateLimiter {&#10;&#9;interval := time.Second / time.Duration(requestsPerSecond)&#10;&#9;return &amp;RateLimiter{&#10;&#9;&#9;ticker: time.NewTicker(interval),&#10;&#9;}&#10;}&#10;&#10;// Wait 等待直到可以发送下一个请求&#10;func (r *RateLimiter) Wait() {&#10;&#9;&lt;-r.ticker.C&#10;}&#10;&#10;// Stop 停止速率限制器&#10;func (r *RateLimiter) Stop() {&#10;&#9;r.ticker.Stop()&#10;}&#10;" />
              <option name="updatedContent" value="package download&#10;&#10;import (&#10;&#9;&quot;encoding/json&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;net&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;net/url&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// EtherscanConfig Etherscan API 配置&#10;type EtherscanConfig struct {&#10;&#9;APIKey  string&#10;&#9;BaseURL string&#10;&#9;Proxy   string // 新增：可选的 HTTP 代理 URL（例如 http://127.0.0.1:7897）&#10;}&#10;&#10;// EtherscanResponse Etherscan API 响应结构&#10;type EtherscanResponse struct {&#10;&#9;Status  string `json:&quot;status&quot;`&#10;&#9;Message string `json:&quot;message&quot;`&#10;&#9;Result  []struct {&#10;&#9;&#9;SourceCode           string `json:&quot;SourceCode&quot;`&#10;&#9;&#9;ABI                  string `json:&quot;ABI&quot;`&#10;&#9;&#9;ContractName         string `json:&quot;ContractName&quot;`&#10;&#9;&#9;CompilerVersion      string `json:&quot;CompilerVersion&quot;`&#10;&#9;&#9;OptimizationUsed     string `json:&quot;OptimizationUsed&quot;`&#10;&#9;&#9;Runs                 string `json:&quot;Runs&quot;`&#10;&#9;&#9;ConstructorArguments string `json:&quot;ConstructorArguments&quot;`&#10;&#9;&#9;EVMVersion           string `json:&quot;EVMVersion&quot;`&#10;&#9;&#9;Library              string `json:&quot;Library&quot;`&#10;&#9;&#9;LicenseType          string `json:&quot;LicenseType&quot;`&#10;&#9;&#9;Proxy                string `json:&quot;Proxy&quot;`&#10;&#9;&#9;Implementation       string `json:&quot;Implementation&quot;`&#10;&#9;&#9;SwarmSource          string `json:&quot;SwarmSource&quot;`&#10;&#9;} `json:&quot;result&quot;`&#10;}&#10;&#10;// GetContractSource 从 Etherscan 获取合约源代码和验证状态&#10;func GetContractSource(address string, config EtherscanConfig) (sourceCode string, isVerified bool, err error) {&#10;&#9;// 清理输入&#10;&#9;address = strings.TrimSpace(address)&#10;&#9;if address == &quot;&quot; {&#10;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;空的地址传入 GetContractSource&quot;)&#10;&#9;}&#10;&#10;&#9;// 构建 API URL 使用 url.Values 避免拼接错误&#10;&#9;base := strings.TrimRight(config.BaseURL, &quot;/&quot;)&#10;&#9;u, err := url.Parse(base)&#10;&#9;if err != nil {&#10;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;解析 Etherscan BaseURL 失败: %w&quot;, err)&#10;&#9;}&#10;&#9;u.Path = strings.TrimRight(u.Path, &quot;/&quot;) + &quot;/api&quot;&#10;&#10;&#9;q := url.Values{}&#10;&#9;q.Set(&quot;module&quot;, &quot;contract&quot;)&#10;&#9;q.Set(&quot;action&quot;, &quot;getsourcecode&quot;)&#10;&#9;q.Set(&quot;address&quot;, address)&#10;&#9;q.Set(&quot;apikey&quot;, strings.TrimSpace(config.APIKey))&#10;&#9;// chainid 可选保留&#10;&#9;q.Set(&quot;chainid&quot;, &quot;1&quot;)&#10;&#10;&#9;u.RawQuery = q.Encode()&#10;&#9;finalURL := u.String()&#10;&#10;&#9;// 准备 HTTP 客户端（超时与可选代理）&#10;&#9;client := &amp;http.Client{&#10;&#9;&#9;Timeout: 20 * time.Second, // 稍微延长超时时间以减少偶发超时&#10;&#9;}&#10;&#10;&#9;if strings.TrimSpace(config.Proxy) != &quot;&quot; {&#10;&#9;&#9;if pu, perr := url.Parse(config.Proxy); perr == nil {&#10;&#9;&#9;&#9;client.Transport = &amp;http.Transport{&#10;&#9;&#9;&#9;&#9;Proxy: http.ProxyURL(pu),&#10;&#9;&#9;&#9;}&#10;&#9;&#9;} else {&#10;&#9;&#9;&#9;// 代理解析失败直接返回错误，调用方会回退为字节码&#10;&#9;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;解析 Etherscan proxy 失败: %w&quot;, perr)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// 重试逻辑：短暂网络错误/EOF/超时时重试&#10;&#9;var lastErr error&#10;&#9;maxAttempts := 3&#10;&#9;for attempt := 1; attempt &lt;= maxAttempts; attempt++ {&#10;&#9;&#9;// 创建请求并加上 User-Agent&#10;&#9;&#9;req, _ := http.NewRequest(&quot;GET&quot;, finalURL, nil)&#10;&#9;&#9;req.Header.Set(&quot;User-Agent&quot;, &quot;solidity-excavator/1.0 (+https://github.com/)&quot;)&#10;&#10;&#9;&#9;resp, err := client.Do(req)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;lastErr = err&#10;&#9;&#9;&#9;// 判断是否为临时或超时错误，如果是则重试&#10;&#9;&#9;&#9;if isTemporaryNetErr(err) &amp;&amp; attempt &lt; maxAttempts {&#10;&#9;&#9;&#9;&#9;sleep := time.Duration(attempt) * 500 * time.Millisecond&#10;&#9;&#9;&#9;&#9;time.Sleep(sleep)&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;// 非临时错误或最后一次尝试 -&gt; 返回网络错误&#10;&#9;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;请求 Etherscan API 失败: %w (url=%s)&quot;, err, finalURL)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 确保关闭响应体&#10;&#9;&#9;body, readErr := io.ReadAll(resp.Body)&#10;&#9;&#9;resp.Body.Close()&#10;&#9;&#9;if readErr != nil {&#10;&#9;&#9;&#9;lastErr = readErr&#10;&#9;&#9;&#9;// 对于意外 EOF 等可重试的读取错误做重试&#10;&#9;&#9;&#9;if (readErr == io.ErrUnexpectedEOF || isTemporaryNetErr(readErr)) &amp;&amp; attempt &lt; maxAttempts {&#10;&#9;&#9;&#9;&#9;time.Sleep(time.Duration(attempt) * 500 * time.Millisecond)&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;读取 Etherscan 响应失败: %w (url=%s)&quot;, readErr, finalURL)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 检查 HTTP 状态码&#10;&#9;&#9;if resp.StatusCode != http.StatusOK {&#10;&#9;&#9;&#9;// 返回 body 片段有助于定位错误&#10;&#9;&#9;&#9;snippet := string(body)&#10;&#9;&#9;&#9;if len(snippet) &gt; 1024 {&#10;&#9;&#9;&#9;&#9;snippet = snippet[:1024]&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;Etherscan 返回非 200 状态: %d, body: %s&quot;, resp.StatusCode, snippet)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 解析 JSON&#10;&#9;&#9;var etherscanResp EtherscanResponse&#10;&#9;&#9;if jerr := json.Unmarshal(body, &amp;etherscanResp); jerr != nil {&#10;&#9;&#9;&#9;lastErr = jerr&#10;&#9;&#9;&#9;// JSON 解析错误通常不可恢复，但做少量重试以应对偶发损坏&#10;&#9;&#9;&#9;if attempt &lt; maxAttempts {&#10;&#9;&#9;&#9;&#9;time.Sleep(time.Duration(attempt) * 300 * time.Millisecond)&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;解析 Etherscan JSON 失败: %w (url=%s)&quot;, jerr, finalURL)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 如果 API 返回 status != &quot;1&quot;，则表示未验证或其它业务层面的问题（不是网络错误）&#10;&#9;&#9;if etherscanResp.Status != &quot;1&quot; {&#10;&#9;&#9;&#9;return &quot;&quot;, false, nil&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 找到结果并检查 SourceCode&#10;&#9;&#9;if len(etherscanResp.Result) == 0 {&#10;&#9;&#9;&#9;return &quot;&quot;, false, nil&#10;&#9;&#9;}&#10;&#9;&#9;res := etherscanResp.Result[0]&#10;&#9;&#9;if strings.TrimSpace(res.SourceCode) == &quot;&quot; {&#10;&#9;&#9;&#9;// 合约未验证&#10;&#9;&#9;&#9;return &quot;&quot;, false, nil&#10;&#9;&#9;}&#10;&#9;&#9;// 成功获取已验证源码&#10;&#9;&#9;return res.SourceCode, true, nil&#10;&#9;}&#10;&#10;&#9;// 所有尝试失败，返回最后一个错误&#10;&#9;if lastErr != nil {&#10;&#9;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;请求 Etherscan 多次失败: %w (url=%s)&quot;, lastErr, finalURL)&#10;&#9;}&#10;&#9;return &quot;&quot;, false, fmt.Errorf(&quot;请求 Etherscan 未知错误 (url=%s)&quot;, finalURL)&#10;}&#10;&#10;// isTemporaryNetErr 判断是否为可重试的网络错误&#10;func isTemporaryNetErr(err error) bool {&#10;&#9;if err == nil {&#10;&#9;&#9;return false&#10;&#9;}&#10;&#9;// net.Error 暴露 Timeout() / Temporary()&#10;&#9;if ne, ok := err.(net.Error); ok {&#10;&#9;&#9;return ne.Timeout() || ne.Temporary()&#10;&#9;}&#10;&#9;// 常见的 IO 错误也视为临时&#10;&#9;if err == io.ErrUnexpectedEOF || err == io.EOF {&#10;&#9;&#9;return true&#10;&#9;}&#10;&#9;// 其余默认不重试&#10;&#9;return false&#10;}&#10;&#10;// RateLimiter 简单的速率限制器&#10;type RateLimiter struct {&#10;&#9;ticker *time.Ticker&#10;}&#10;&#10;// NewRateLimiter 创建速率限制器（每秒最多 requestsPerSecond 个请求）&#10;func NewRateLimiter(requestsPerSecond int) *RateLimiter {&#10;&#9;interval := time.Second / time.Duration(requestsPerSecond)&#10;&#9;return &amp;RateLimiter{&#10;&#9;&#9;ticker: time.NewTicker(interval),&#10;&#9;}&#10;}&#10;&#10;// Wait 等待直到可以发送下一个请求&#10;func (r *RateLimiter) Wait() {&#10;&#9;&lt;-r.ticker.C&#10;}&#10;&#10;// Stop 停止速率限制器&#10;func (r *RateLimiter) Stop() {&#10;&#9;r.ticker.Stop()&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/handler/mode1_targeted.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/handler/mode1_targeted.go" />
              <option name="originalContent" value="package handler&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/config&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;parser &quot;github.com/admi-n/solidity-Excavator/src/internal/ai/parser&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/core&quot;&#10;)&#10;&#10;// RunMode1 执行 Mode1 定向扫描&#10;func RunMode1(cfg internal.ScanConfig) ([]parser.ScanResult, error) {&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Println(&quot;[Mode1] 启动定向扫描...&quot;)&#10;&#9;}&#10;&#10;&#9;// 1️⃣ 获取目标合约列表&#10;&#9;targets, err := loadTargets(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;[Mode1] 加载目标失败: %w&quot;, err)&#10;&#9;}&#10;&#9;if len(targets) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;[Mode1] 未找到扫描目标&quot;)&#10;&#9;}&#10;&#10;&#9;var results []parser.ScanResult&#10;&#10;&#9;// 2️⃣ 遍历每个合约&#10;&#9;for _, contract := range targets {&#10;&#9;&#9;if cfg.Verbose {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 扫描合约: %s\n&quot;, contract.Address)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2a. 构建 Prompt&#10;&#9;&#9;prompt := buildPrompt(cfg, contract)&#10;&#9;&#9;// 2b. 加载漏洞复现 EXP (占位)&#10;&#9;&#9;expCode := loadExp(cfg.Strategy)&#10;&#10;&#9;&#9;// 2c. 调用 Core 层执行扫描&#10;&#9;&#9;rawOutput, err := core.Mode1Scan(contract, prompt, expCode, cfg)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 警告: 扫描合约 %s 失败: %v\n&quot;, contract.Address, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2d. 调用 AI Parser 将原始输出转换为 ScanResult&#10;&#9;&#9;structured, err := parser.Parser.Parse(rawOutput)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 警告: 解析合约 %s 输出失败: %v\n&quot;, contract.Address, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;results = append(results, structured...)&#10;&#10;&#9;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;}&#10;&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;[Mode1] 扫描完成，找到 %d 个漏洞条目\n&quot;, len(results))&#10;&#9;}&#10;&#10;&#9;return results, nil&#10;}&#10;&#10;// loadTargets 占位函数：根据 cfg.TargetSource 获取目标合约列表&#10;func loadTargets(cfg internal.ScanConfig) ([]internal.Contract, error) {&#10;&#9;// 如果目标来自数据库，则尝试从 PostgreSQL 拉取（使用 DATABASE_URL 环境变量或者外部传入的 DSN）&#10;&#9;if cfg.TargetSource == &quot;db&quot; {&#10;&#9;&#9;dsn := os.Getenv(&quot;DATABASE_URL&quot;)&#10;&#9;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;DATABASE_URL 未设置，无法从数据库加载目标&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;pool, err := config.InitDB(dsn)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;初始化数据库失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;// 使用短超时的 context 加载数据&#10;&#9;&#9;ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)&#10;&#9;&#9;defer cancel()&#10;&#9;&#9;// limit 可根据需求调整；这里使用 1000 为示例&#10;&#9;&#9;contracts, err := config.GetContracts(ctx, pool, 1000)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;从数据库加载合约失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;return contracts, nil&#10;&#9;}&#10;&#10;&#9;// 默认回退：file 或 mock（方便本地测试）&#10;&#9;mock := []internal.Contract{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Address: &quot;0xDEADBEEF...&quot;,&#10;&#9;&#9;&#9;Code:    &quot;contract Mock { function test() public {} }&quot;,&#10;&#9;&#9;&#9;// 其余字段可为空/零值&#10;&#9;&#9;},&#10;&#9;}&#10;&#9;return mock, nil&#10;}&#10;&#10;// buildPrompt 占位函数&#10;func buildPrompt(cfg internal.ScanConfig, contract internal.Contract) string {&#10;&#9;return fmt.Sprintf(&quot;请分析合约 %s 的漏洞，使用策略 %s&quot;, contract.Address, cfg.Strategy)&#10;}&#10;&#10;// loadExp 占位函数&#10;func loadExp(strategy string) string {&#10;&#9;return &quot;// 漏洞复现代码占位&quot;&#10;}&#10;" />
              <option name="updatedContent" value="package handler&#10;&#10;import (&#10;&#9;&quot;bufio&quot;&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/config&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;parser &quot;github.com/admi-n/solidity-Excavator/src/internal/ai/parser&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/core&quot;&#10;)&#10;&#10;// RunMode1 执行 Mode1 定向扫描&#10;func RunMode1(cfg internal.ScanConfig) ([]parser.ScanResult, error) {&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Println(&quot;[Mode1] 启动定向扫描...&quot;)&#10;&#9;}&#10;&#10;&#9;// 1️⃣ 获取目标合约列表&#10;&#9;targets, err := loadTargets(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;[Mode1] 加载目标失败: %w&quot;, err)&#10;&#9;}&#10;&#9;if len(targets) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;[Mode1] 未找到扫描目标&quot;)&#10;&#9;}&#10;&#10;&#9;var results []parser.ScanResult&#10;&#10;&#9;// 2️⃣ 遍历每个合约&#10;&#9;for _, contract := range targets {&#10;&#9;&#9;if cfg.Verbose {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 扫描合约: %s\n&quot;, contract.Address)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2a. 构建 Prompt&#10;&#9;&#9;prompt := buildPrompt(cfg, contract)&#10;&#9;&#9;// 2b. 加载漏洞复现 EXP (占位)&#10;&#9;&#9;expCode := loadExp(cfg.Strategy)&#10;&#10;&#9;&#9;// 2c. 调用 Core 层执行扫描&#10;&#9;&#9;rawOutput, err := core.Mode1Scan(contract, prompt, expCode, cfg)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 警告: 扫描合约 %s 失败: %v\n&quot;, contract.Address, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2d. 调用 AI Parser 将原始输出转换为 ScanResult&#10;&#9;&#9;structured, err := parser.Parser.Parse(rawOutput)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 警告: 解析合约 %s 输出失败: %v\n&quot;, contract.Address, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;results = append(results, structured...)&#10;&#10;&#9;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;}&#10;&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;[Mode1] 扫描完成，找到 %d 个漏洞条目\n&quot;, len(results))&#10;&#9;}&#10;&#10;&#9;return results, nil&#10;}&#10;&#10;// loadTargets 占位函数：根据 cfg.TargetSource 获取目标合约列表&#10;func loadTargets(cfg internal.ScanConfig) ([]internal.Contract, error) {&#10;&#9;// 如果目标来自数据库（直接拉取全表或分页），保留现有行为&#10;&#9;if cfg.TargetSource == &quot;db&quot; {&#10;&#9;&#9;dsn := os.Getenv(&quot;DATABASE_URL&quot;)&#10;&#9;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;DATABASE_URL 未设置，无法从数据库加载目标&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;pool, err := config.InitDB(dsn)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;初始化数据库失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;// 使用短超时的 context 加载数据&#10;&#9;&#9;ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)&#10;&#9;&#9;defer cancel()&#10;&#9;&#9;// limit 可根据需求调整；这里使用 1000 为示例&#10;&#9;&#9;contracts, err := config.GetContracts(ctx, pool, 1000)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;从数据库加载合约失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;return contracts, nil&#10;&#9;}&#10;&#10;&#9;// 如果目标来自文件（txt），则读取每行地址并用数据库按地址匹配合约信息&#10;&#9;if cfg.TargetSource == &quot;file&quot; {&#10;&#9;&#9;if cfg.TargetFile == &quot;&quot; {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;cfg.TargetFile 为空，无法读取地址文件&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;f, err := os.Open(cfg.TargetFile)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;打开地址文件失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;defer f.Close()&#10;&#10;&#9;&#9;var addrs []string&#10;&#9;&#9;scanner := bufio.NewScanner(f)&#10;&#9;&#9;for scanner.Scan() {&#10;&#9;&#9;&#9;line := strings.TrimSpace(scanner.Text())&#10;&#9;&#9;&#9;if line == &quot;&quot; {&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;addrs = append(addrs, line)&#10;&#9;&#9;}&#10;&#9;&#9;if err := scanner.Err(); err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;读取地址文件失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if len(addrs) == 0 {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;地址文件中未找到任何地址&quot;)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 使用 DB 来匹配这些地址并获取合约信息&#10;&#9;&#9;dsn := os.Getenv(&quot;DATABASE_URL&quot;)&#10;&#9;&#9;if dsn == &quot;&quot; {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;DATABASE_URL 未设置，无法从数据库加载目标&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;pool, err := config.InitDB(dsn)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;初始化数据库失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)&#10;&#9;&#9;defer cancel()&#10;&#9;&#9;contracts, err := config.GetContractsByAddresses(ctx, pool, addrs)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;按地址从数据库加载合约失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;return contracts, nil&#10;&#9;}&#10;&#10;&#9;// 默认回退：mock（方便本地测试）&#10;&#9;mock := []internal.Contract{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Address: &quot;0xDEADBEEF...&quot;,&#10;&#9;&#9;&#9;Code:    &quot;contract Mock { function test() public {} }&quot;,&#10;&#9;&#9;&#9;// 其余字段可为空/零值&#10;&#9;&#9;},&#10;&#9;}&#10;&#9;return mock, nil&#10;}&#10;&#10;// buildPrompt 占位函数&#10;func buildPrompt(cfg internal.ScanConfig, contract internal.Contract) string {&#10;&#9;return fmt.Sprintf(&quot;请分析合约 %s 的漏洞，使用策略 %s&quot;, contract.Address, cfg.Strategy)&#10;}&#10;&#10;// loadExp 占位函数&#10;func loadExp(strategy string) string {&#10;&#9;return &quot;// 漏洞复现代码占位&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/types.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/types.go" />
              <option name="originalContent" value="package internal&#10;&#10;import &quot;time&quot;&#10;&#10;type ScanConfig struct {&#10;&#9;AIProvider   string&#10;&#9;Mode         string&#10;&#9;Strategy     string&#10;&#9;TargetSource string&#10;&#9;TargetFile   string&#10;&#9;Chain        string&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#9;BlockRange   *BlockRange&#10;}&#10;&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;// 新增：表示待扫描的合约基础信息&#10;type Contract struct {&#10;&#9;Address string&#10;&#9;Code    string&#10;}&#10;" />
              <option name="updatedContent" value="package internal&#10;&#10;import &quot;time&quot;&#10;&#10;type ScanConfig struct {&#10;&#9;AIProvider   string&#10;&#9;Mode         string&#10;&#9;Strategy     string&#10;&#9;TargetSource string&#10;&#9;TargetFile   string&#10;&#9;Chain        string&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#9;BlockRange   *BlockRange&#10;}&#10;&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;// Contract 表示待扫描的合约基础信息，包含数据库表字段映射&#10;type Contract struct {&#10;&#9;Address      string    `json:&quot;address&quot;`       // 合约地址&#10;&#9;Code         string    `json:&quot;contract&quot;`      // 合约代码&#10;&#9;Balance      string    `json:&quot;balance&quot;`       // 余额（以字符串保存以避免精度/类型问题）&#10;&#9;IsOpenSource bool      `json:&quot;isOpenSource&quot;`  // 是否开源 (true/false 对应 1/0)&#10;&#9;CreateTime   time.Time `json:&quot;createtime&quot;`    // 创建时间&#10;&#9;CreateBlock  uint64    `json:&quot;createblock&quot;`   // 创建区块号&#10;&#9;TxLast       time.Time `json:&quot;txlast&quot;`        // 最后一次交互时间&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>