<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/cmd/cli.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/cmd/cli.go" />
              <option name="originalContent" value="package cmd&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;flag&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/handler&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// Reporter 先不写&#10;&#10;// CLIConfig 保存解析好的 CLI 选项以及供扫描器使用的规范化字&#10;// 段。&#10;type CLIConfig struct {&#10;&#9;AIProvider   string // 例如 chatgpt5&#10;&#9;Mode         string // mode1 | mode2 | mode3&#10;&#9;Strategy     string // 例如 hourglass-vul 或 &quot;all&quot;&#10;&#9;TargetSource string // &quot;db&quot; 或 &quot;file&quot; - 从哪里获取目标列表&#10;&#9;BlockRange   *BlockRange&#10;&#9;TargetFile   string // 包含地址/批次的 YAML 路径&#10;&#9;Chain        string // eth | bsc | arb&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#10;&#9;// Reporter 相关配置&#10;&#9;//ReportEnabled bool     // 是否生成报告&#10;&#9;//ReportFormats []string // 支持的格式：md,json,html,pdf&#10;&#9;//ReportOut     string   // 报告输出目录或前缀&#10;}&#10;&#10;// BlockRange 简单的起止区块范围结构&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;func (b *BlockRange) String() string {&#10;&#9;if b == nil {&#10;&#9;&#9;return &quot;&quot;&#10;&#9;}&#10;&#9;return fmt.Sprintf(&quot;%d-%d&quot;, b.Start, b.End)&#10;}&#10;&#10;// parseBlockRange 解析类似 &quot;1-220234&quot; 或 &quot;1000-&quot;（开放结束）的字符串并返回 BlockRange。&#10;func parseBlockRange(s string) (*BlockRange, error) {&#10;&#9;if strings.TrimSpace(s) == &quot;&quot; {&#10;&#9;&#9;return nil, nil&#10;&#9;}&#10;&#9;parts := strings.Split(s, &quot;-&quot;)&#10;&#9;if len(parts) != 2 {&#10;&#9;&#9;return nil, errors.New(&quot;invalid block range format, expected start-end&quot;)&#10;&#9;}&#10;&#9;startStr := strings.TrimSpace(parts[0])&#10;&#9;endStr := strings.TrimSpace(parts[1])&#10;&#9;var br BlockRange&#10;&#9;if startStr == &quot;&quot; {&#10;&#9;&#9;return nil, errors.New(&quot;start block required&quot;)&#10;&#9;}&#10;&#9;start, err := strconv.ParseUint(startStr, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid start block: %w&quot;, err)&#10;&#9;}&#10;&#9;br.Start = start&#10;&#9;if endStr == &quot;&quot; {&#10;&#9;&#9;br.End = ^uint64(0) // max uint64 to indicate open-ended&#10;&#9;} else {&#10;&#9;&#9;end, err := strconv.ParseUint(endStr, 10, 64)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;invalid end block: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if end &lt; start {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;end block must be &gt;= start block&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;br.End = end&#10;&#9;}&#10;&#9;return &amp;br, nil&#10;}&#10;&#10;// Validate 检查 CLIConfig 的必需/一致性输入。&#10;func (c *CLIConfig) Validate() error {&#10;&#9;if c.AIProvider == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-ai is required (e.g. -ai chatgpt5)&quot;)&#10;&#9;}&#10;&#9;if c.Mode == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-m (mode) is required: mode1|mode2|mode3&quot;)&#10;&#9;}&#10;&#9;if c.Mode != &quot;mode1&quot; &amp;&amp; c.Mode != &quot;mode2&quot; &amp;&amp; c.Mode != &quot;mode3&quot; {&#10;&#9;&#9;return errors.New(&quot;-m must be one of: mode1, mode2, mode3&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource != &quot;db&quot; &amp;&amp; c.TargetSource != &quot;file&quot; {&#10;&#9;&#9;return errors.New(&quot;-t must be either 'db' or 'file'&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource == &quot;file&quot; &amp;&amp; c.TargetFile == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-t-file is required when -t=file&quot;)&#10;&#9;}&#10;&#9;if c.Chain == &quot;&quot; {&#10;&#9;&#9;c.Chain = &quot;eth&quot; // default&#10;&#9;}&#10;&#9;if c.Concurrency &lt;= 0 {&#10;&#9;&#9;c.Concurrency = 4&#10;&#9;}&#10;&#10;&#9;// Validate report formats if reporting enabled&#10;&#9;//if c.ReportEnabled {&#10;&#9;//&#9;if c.ReportOut == &quot;&quot; {&#10;&#9;//&#9;&#9;return errors.New(&quot;-report-out is required when -report is enabled&quot;)&#10;&#9;//&#9;}&#10;&#9;//&#9;allowed := map[string]bool{&quot;md&quot;: true, &quot;json&quot;: true, &quot;html&quot;: true, &quot;pdf&quot;: true}&#10;&#9;//&#9;for _, f := range c.ReportFormats {&#10;&#9;//&#9;&#9;if !allowed[strings.ToLower(f)] {&#10;&#9;//&#9;&#9;&#9;return fmt.Errorf(&quot;unsupported report format: %s&quot;, f)&#10;&#9;//&#9;&#9;}&#10;&#9;//&#9;}&#10;&#9;//}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// ParseFlags 解析 os.Args 并返回 CLIConfig 或错误。用于从 main 调用。&#10;func ParseFlags() (*CLIConfig, error) {&#10;&#9;fs := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)&#10;&#9;fs.Usage = func() {&#10;&#9;&#9;w := fs.Output()&#10;&#9;&#9;fmt.Fprintln(w, &quot;用法: excavator -ai &lt;provider&gt; -m &lt;mode&gt; [选项]&quot;)&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;选项:&quot;)&#10;&#9;&#9;fs.PrintDefaults()&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;示例:&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s hourglass-vul -t file -t-file ./data/source_contracts/sample.yaml -c eth&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s all -t db -t-block 1-220234 -c eth&quot;)&#10;&#9;}&#10;&#10;&#9;ai := fs.String(&quot;ai&quot;, &quot;&quot;, &quot;AI provider to use (e.g. chatgpt5)&quot;)&#10;&#9;mode := fs.String(&quot;m&quot;, &quot;&quot;, &quot;Mode to run: mode1(targeted) | mode2(fuzzy) | mode3(general)&quot;)&#10;&#9;strategy := fs.String(&quot;s&quot;, &quot;all&quot;, &quot;Strategy/prompt name in strategy/prompts/&lt;mode&gt;/ (or 'all')&quot;)&#10;&#9;target := fs.String(&quot;t&quot;, &quot;db&quot;, &quot;Target source: 'db' or 'file' (default db)&quot;)&#10;&#9;blockRange := fs.String(&quot;t-block&quot;, &quot;&quot;, &quot;Block range for scanning (format start-end, e.g. 1-220234)&quot;)&#10;&#9;tfile := fs.String(&quot;t-file&quot;, &quot;&quot;, &quot;YAML file path when -t=file; can be a directory for batching&quot;)&#10;&#9;chain := fs.String(&quot;c&quot;, &quot;eth&quot;, &quot;Chain to scan: eth | bsc | arb (default eth)&quot;)&#10;&#9;concurrency := fs.Int(&quot;concurrency&quot;, 4, &quot;Worker concurrency&quot;)&#10;&#9;verbose := fs.Bool(&quot;v&quot;, false, &quot;Verbose output&quot;)&#10;&#9;timeout := fs.Duration(&quot;timeout&quot;, 30*time.Second, &quot;Per-AI request timeout&quot;)&#10;&#9;//report := fs.Bool(&quot;report&quot;, false, &quot;Whether to generate report files after scan (default false)&quot;)&#10;&#9;//reportFormats := fs.String(&quot;report-formats&quot;, &quot;md,json&quot;, &quot;Comma-separated output formats: md,json,html,pdf&quot;)&#10;&#9;//reportOut := fs.String(&quot;report-out&quot;, &quot;./reports&quot;, &quot;Output directory or storage prefix for reports&quot;)&#10;&#10;&#9;if err := fs.Parse(os.Args[1:]); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;cfg := &amp;CLIConfig{&#10;&#9;&#9;AIProvider:   strings.TrimSpace(*ai),&#10;&#9;&#9;Mode:         strings.TrimSpace(*mode),&#10;&#9;&#9;Strategy:     strings.TrimSpace(*strategy),&#10;&#9;&#9;TargetSource: strings.TrimSpace(*target),&#10;&#9;&#9;TargetFile:   strings.TrimSpace(*tfile),&#10;&#9;&#9;Chain:        strings.TrimSpace(*chain),&#10;&#9;&#9;Concurrency:  *concurrency,&#10;&#9;&#9;Verbose:      *verbose,&#10;&#9;&#9;Timeout:      *timeout,&#10;&#9;&#9;//ReportEnabled: *report,&#10;&#9;&#9;//ReportOut:     strings.TrimSpace(*reportOut),&#10;&#9;}&#10;&#10;&#9;// parse report formats&#10;&#9;//if strings.TrimSpace(*reportFormats) != &quot;&quot; {&#10;&#9;//&#9;parts := strings.Split(*reportFormats, &quot;,&quot;)&#10;&#9;//&#9;for i := range parts {&#10;&#9;//&#9;&#9;parts[i] = strings.ToLower(strings.TrimSpace(parts[i]))&#10;&#9;//&#9;}&#10;&#9;//&#9;cfg.ReportFormats = parts&#10;&#9;//}&#10;&#10;&#9;if strings.TrimSpace(*blockRange) != &quot;&quot; {&#10;&#9;&#9;br, err := parseBlockRange(*blockRange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;cfg.BlockRange = br&#10;&#9;}&#10;&#10;&#9;// normalize target source&#10;&#9;cfg.TargetSource = strings.ToLower(cfg.TargetSource)&#10;&#9;if cfg.TargetSource == &quot;yaml&quot; {&#10;&#9;&#9;cfg.TargetSource = &quot;file&quot; // accept yaml alias&#10;&#9;}&#10;&#10;&#9;// 如果提供了文件路径但不是绝对路径，则将其转为相对于当前工作目录&#10;&#9;if cfg.TargetFile != &quot;&quot; {&#10;&#9;&#9;if !filepath.IsAbs(cfg.TargetFile) {&#10;&#9;&#9;&#9;cwd, _ := os.Getwd()&#10;&#9;&#9;&#9;cfg.TargetFile = filepath.Join(cwd, cfg.TargetFile)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// normalize report-out to absolute path if local&#10;&#9;//cfg.ReportEnabled = *report&#10;&#9;//if cfg.ReportEnabled {&#10;&#9;//&#9;cfg.ReportOut = strings.TrimSpace(*reportOut)&#10;&#9;//&#9;parts := strings.Split(*reportFormats, &quot;,&quot;)&#10;&#9;//&#9;for i := range parts {&#10;&#9;//&#9;&#9;parts[i] = strings.ToLower(strings.TrimSpace(parts[i]))&#10;&#9;//&#9;}&#10;&#9;//&#9;cfg.ReportFormats = parts&#10;&#9;//}&#10;&#10;&#9;if err := cfg.Validate(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return cfg, nil&#10;}&#10;&#10;// Run 是一个便利包装，解析 flags 并分派到相应处理器。&#10;// 用你实际的内部/核心逻辑替换占位处理调用。&#10;func Run() error {&#10;&#9;cfg, err := ParseFlags()&#10;&#9;if err != nil {&#10;&#9;&#9;if errors.Is(err, flag.ErrHelp) {&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;}&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;使用配置运行 Excavator: %+v\n&quot;, cfg)&#10;&#9;}&#10;&#10;&#9;// TODO: 与内部/核心处理器集成。下面为示例分派。&#10;&#9;switch cfg.Mode {&#10;&#9;case &quot;mode1&quot;:&#10;&#9;&#9;results, err := handler.RunMode1(cfg)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;Mode1 扫描失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;fmt.Printf(&quot;Mode1 扫描完成，共找到 %d 个漏洞条目\n&quot;, len(results))&#10;&#9;&#9;fmt.Println(&quot;分派到 mode1（定向）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;case &quot;mode2&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode2（模糊）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;case &quot;mode3&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode3（通用）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;default:&#10;&#9;&#9;return errors.New(&quot;unsupported mode&quot;)&#10;&#9;}&#10;&#10;&#9;// Reporter 集成点（占位）&#10;&#9;//if cfg.ReportEnabled {&#10;&#9;//&#9;// 目前这里仅为占位提示 —— 实际应调用 internal/reporter 生成并保存报告。&#10;&#9;//&#9;// 示例伪代码：&#10;&#9;//&#9;// reportManager := reporter.New(cfg.ReportOut)&#10;&#9;//&#9;// meta, err := reportManager.Generate(ctx, scanResult, cfg.ReportFormats)&#10;&#9;//&#9;// if err != nil { log... }&#10;&#9;//&#9;// if cfg.ReportNotify { reportManager.Notify(meta) }&#10;&#9;//&#9;fmt.Printf(&quot;报告已启用 → 格式: %v, 输出: %s\n&quot;, cfg.ReportFormats, cfg.ReportOut)&#10;&#9;//}&#10;&#9;return nil&#10;}&#10;&#10;// 小帮助函数：PrintFatal 将错误打印到 stderr 并以非零代码退出。&#10;func PrintFatal(err error) {&#10;&#9;if err == nil {&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;fmt.Fprintln(os.Stderr, &quot;错误:&quot;, err)&#10;&#9;os.Exit(1)&#10;}&#10;" />
              <option name="updatedContent" value="package cmd&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;flag&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/handler&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// Reporter 先不写&#10;&#10;// CLIConfig 保存解析好的 CLI 选项以及供扫描器使用的规范化字&#10;// 段。&#10;type CLIConfig struct {&#10;&#9;AIProvider   string // 例如 chatgpt5&#10;&#9;Mode         string // mode1 | mode2 | mode3&#10;&#9;Strategy     string // 例如 hourglass-vul 或 &quot;all&quot;&#10;&#9;TargetSource string // &quot;db&quot; 或 &quot;file&quot; - 从哪里获取目标列表&#10;&#9;BlockRange   *BlockRange&#10;&#9;TargetFile   string // 包含地址/批次的 YAML 路径&#10;&#9;Chain        string // eth | bsc | arb&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#10;&#9;// Reporter 相关配置&#10;&#9;//ReportEnabled bool     // 是否生成报告&#10;&#9;//ReportFormats []string // 支持的格式：md,json,html,pdf&#10;&#9;//ReportOut     string   // 报告输出目录或前缀&#10;}&#10;&#10;// BlockRange 简单的起止区块范围结构&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;func (b *BlockRange) String() string {&#10;&#9;if b == nil {&#10;&#9;&#9;return &quot;&quot;&#10;&#9;}&#10;&#9;return fmt.Sprintf(&quot;%d-%d&quot;, b.Start, b.End)&#10;}&#10;&#10;// parseBlockRange 解析类似 &quot;1-220234&quot; 或 &quot;1000-&quot;（开放结束）的字符串并返回 BlockRange。&#10;func parseBlockRange(s string) (*BlockRange, error) {&#10;&#9;if strings.TrimSpace(s) == &quot;&quot; {&#10;&#9;&#9;return nil, nil&#10;&#9;}&#10;&#9;parts := strings.Split(s, &quot;-&quot;)&#10;&#9;if len(parts) != 2 {&#10;&#9;&#9;return nil, errors.New(&quot;invalid block range format, expected start-end&quot;)&#10;&#9;}&#10;&#9;startStr := strings.TrimSpace(parts[0])&#10;&#9;endStr := strings.TrimSpace(parts[1])&#10;&#9;var br BlockRange&#10;&#9;if startStr == &quot;&quot; {&#10;&#9;&#9;return nil, errors.New(&quot;start block required&quot;)&#10;&#9;}&#10;&#9;start, err := strconv.ParseUint(startStr, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid start block: %w&quot;, err)&#10;&#9;}&#10;&#9;br.Start = start&#10;&#9;if endStr == &quot;&quot; {&#10;&#9;&#9;br.End = ^uint64(0) // max uint64 to indicate open-ended&#10;&#9;} else {&#10;&#9;&#9;end, err := strconv.ParseUint(endStr, 10, 64)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;invalid end block: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if end &lt; start {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;end block must be &gt;= start block&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;br.End = end&#10;&#9;}&#10;&#9;return &amp;br, nil&#10;}&#10;&#10;// Validate 检查 CLIConfig 的必需/一致性输入。&#10;func (c *CLIConfig) Validate() error {&#10;&#9;if c.AIProvider == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-ai is required (e.g. -ai chatgpt5)&quot;)&#10;&#9;}&#10;&#9;if c.Mode == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-m (mode) is required: mode1|mode2|mode3&quot;)&#10;&#9;}&#10;&#9;if c.Mode != &quot;mode1&quot; &amp;&amp; c.Mode != &quot;mode2&quot; &amp;&amp; c.Mode != &quot;mode3&quot; {&#10;&#9;&#9;return errors.New(&quot;-m must be one of: mode1, mode2, mode3&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource != &quot;db&quot; &amp;&amp; c.TargetSource != &quot;file&quot; {&#10;&#9;&#9;return errors.New(&quot;-t must be either 'db' or 'file'&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource == &quot;file&quot; &amp;&amp; c.TargetFile == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-t-file is required when -t=file&quot;)&#10;&#9;}&#10;&#9;if c.Chain == &quot;&quot; {&#10;&#9;&#9;c.Chain = &quot;eth&quot; // default&#10;&#9;}&#10;&#9;if c.Concurrency &lt;= 0 {&#10;&#9;&#9;c.Concurrency = 4&#10;&#9;}&#10;&#10;&#9;// Validate report formats if reporting enabled&#10;&#9;//if c.ReportEnabled {&#10;&#9;//&#9;if c.ReportOut == &quot;&quot; {&#10;&#9;//&#9;&#9;return errors.New(&quot;-report-out is required when -report is enabled&quot;)&#10;&#9;//&#9;}&#10;&#9;//&#9;allowed := map[string]bool{&quot;md&quot;: true, &quot;json&quot;: true, &quot;html&quot;: true, &quot;pdf&quot;: true}&#10;&#9;//&#9;for _, f := range c.ReportFormats {&#10;&#9;//&#9;&#9;if !allowed[strings.ToLower(f)] {&#10;&#9;//&#9;&#9;&#9;return fmt.Errorf(&quot;unsupported report format: %s&quot;, f)&#10;&#9;//&#9;&#9;}&#10;&#9;//&#9;}&#10;&#9;//}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// ParseFlags 解析 os.Args 并返回 CLIConfig 或错误。用于从 main 调用。&#10;func ParseFlags() (*CLIConfig, error) {&#10;&#9;fs := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)&#10;&#9;fs.Usage = func() {&#10;&#9;&#9;w := fs.Output()&#10;&#9;&#9;fmt.Fprintln(w, &quot;用法: excavator -ai &lt;provider&gt; -m &lt;mode&gt; [选项]&quot;)&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;选项:&quot;)&#10;&#9;&#9;fs.PrintDefaults()&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;示例:&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s hourglass-vul -t file -t-file ./data/source_contracts/sample.yaml -c eth&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s all -t db -t-block 1-220234 -c eth&quot;)&#10;&#9;}&#10;&#10;&#9;ai := fs.String(&quot;ai&quot;, &quot;&quot;, &quot;AI provider to use (e.g. chatgpt5)&quot;)&#10;&#9;mode := fs.String(&quot;m&quot;, &quot;&quot;, &quot;Mode to run: mode1(targeted) | mode2(fuzzy) | mode3(general)&quot;)&#10;&#9;strategy := fs.String(&quot;s&quot;, &quot;all&quot;, &quot;Strategy/prompt name in strategy/prompts/&lt;mode&gt;/ (or 'all')&quot;)&#10;&#9;target := fs.String(&quot;t&quot;, &quot;db&quot;, &quot;Target source: 'db' or 'file' (default db)&quot;)&#10;&#9;blockRange := fs.String(&quot;t-block&quot;, &quot;&quot;, &quot;Block range for scanning (format start-end, e.g. 1-220234)&quot;)&#10;&#9;tfile := fs.String(&quot;t-file&quot;, &quot;&quot;, &quot;YAML file path when -t=file; can be a directory for batching&quot;)&#10;&#9;chain := fs.String(&quot;c&quot;, &quot;eth&quot;, &quot;Chain to scan: eth | bsc | arb (default eth)&quot;)&#10;&#9;concurrency := fs.Int(&quot;concurrency&quot;, 4, &quot;Worker concurrency&quot;)&#10;&#9;verbose := fs.Bool(&quot;v&quot;, false, &quot;Verbose output&quot;)&#10;&#9;timeout := fs.Duration(&quot;timeout&quot;, 30*time.Second, &quot;Per-AI request timeout&quot;)&#10;&#9;//report := fs.Bool(&quot;report&quot;, false, &quot;Whether to generate report files after scan (default false)&quot;)&#10;&#9;//reportFormats := fs.String(&quot;report-formats&quot;, &quot;md,json&quot;, &quot;Comma-separated output formats: md,json,html,pdf&quot;)&#10;&#9;//reportOut := fs.String(&quot;report-out&quot;, &quot;./reports&quot;, &quot;Output directory or storage prefix for reports&quot;)&#10;&#10;&#9;if err := fs.Parse(os.Args[1:]); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;cfg := &amp;CLIConfig{&#10;&#9;&#9;AIProvider:   strings.TrimSpace(*ai),&#10;&#9;&#9;Mode:         strings.TrimSpace(*mode),&#10;&#9;&#9;Strategy:     strings.TrimSpace(*strategy),&#10;&#9;&#9;TargetSource: strings.TrimSpace(*target),&#10;&#9;&#9;TargetFile:   strings.TrimSpace(*tfile),&#10;&#9;&#9;Chain:        strings.TrimSpace(*chain),&#10;&#9;&#9;Concurrency:  *concurrency,&#10;&#9;&#9;Verbose:      *verbose,&#10;&#9;&#9;Timeout:      *timeout,&#10;&#9;&#9;//ReportEnabled: *report,&#10;&#9;&#9;//ReportOut:     strings.TrimSpace(*reportOut),&#10;&#9;}&#10;&#10;&#9;// parse report formats&#10;&#9;//if strings.TrimSpace(*reportFormats) != &quot;&quot; {&#10;&#9;//&#9;parts := strings.Split(*reportFormats, &quot;,&quot;)&#10;&#9;//&#9;for i := range parts {&#10;&#9;//&#9;&#9;parts[i] = strings.ToLower(strings.TrimSpace(parts[i]))&#10;&#9;//&#9;}&#10;&#9;//&#9;cfg.ReportFormats = parts&#10;&#9;//}&#10;&#10;&#9;if strings.TrimSpace(*blockRange) != &quot;&quot; {&#10;&#9;&#9;br, err := parseBlockRange(*blockRange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;cfg.BlockRange = br&#10;&#9;}&#10;&#10;&#9;// normalize target source&#10;&#9;cfg.TargetSource = strings.ToLower(cfg.TargetSource)&#10;&#9;if cfg.TargetSource == &quot;yaml&quot; {&#10;&#9;&#9;cfg.TargetSource = &quot;file&quot; // accept yaml alias&#10;&#9;}&#10;&#10;&#9;// 如果提供了文件路径但不是绝对路径，则将其转为相对于当前工作目录&#10;&#9;if cfg.TargetFile != &quot;&quot; {&#10;&#9;&#9;if !filepath.IsAbs(cfg.TargetFile) {&#10;&#9;&#9;&#9;cwd, _ := os.Getwd()&#10;&#9;&#9;&#9;cfg.TargetFile = filepath.Join(cwd, cfg.TargetFile)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// normalize report-out to absolute path if local&#10;&#9;//cfg.ReportEnabled = *report&#10;&#9;//if cfg.ReportEnabled {&#10;&#9;//&#9;cfg.ReportOut = strings.TrimSpace(*reportOut)&#10;&#9;//&#9;parts := strings.Split(*reportFormats, &quot;,&quot;)&#10;&#9;//&#9;for i := range parts {&#10;&#9;//&#9;&#9;parts[i] = strings.ToLower(strings.TrimSpace(parts[i]))&#10;&#9;//&#9;}&#10;&#9;//&#9;cfg.ReportFormats = parts&#10;&#9;//}&#10;&#10;&#9;if err := cfg.Validate(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return cfg, nil&#10;}&#10;&#10;// Run 是一个便利包装，解析 flags 并分派到相应处理器。&#10;// 用你实际的内部/核心逻辑替换占位处理调用。&#10;func Run() error {&#10;&#9;cfg, err := ParseFlags()&#10;&#9;if err != nil {&#10;&#9;&#9;if errors.Is(err, flag.ErrHelp) {&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;}&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;使用配置运行 Excavator: %+v\n&quot;, cfg)&#10;&#9;}&#10;&#10;&#9;// 将 CLIConfig 映射到 internal.ScanConfig&#10;&#9;internalCfg := internal.ScanConfig{&#10;&#9;&#9;AIProvider:   cfg.AIProvider,&#10;&#9;&#9;Mode:         cfg.Mode,&#10;&#9;&#9;Strategy:     cfg.Strategy,&#10;&#9;&#9;TargetSource: cfg.TargetSource,&#10;&#9;&#9;TargetFile:   cfg.TargetFile,&#10;&#9;&#9;Chain:        cfg.Chain,&#10;&#9;&#9;Concurrency:  cfg.Concurrency,&#10;&#9;&#9;Verbose:      cfg.Verbose,&#10;&#9;&#9;Timeout:      cfg.Timeout,&#10;&#9;}&#10;&#9;if cfg.BlockRange != nil {&#10;&#9;&#9;internalCfg.BlockRange = &amp;internal.BlockRange{&#10;&#9;&#9;&#9;Start: cfg.BlockRange.Start,&#10;&#9;&#9;&#9;End:   cfg.BlockRange.End,&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;// TODO: 与内部/核心处理器集成。下面为示例分派。&#10;&#9;switch cfg.Mode {&#10;&#9;case &quot;mode1&quot;:&#10;&#9;&#9;results, err := handler.RunMode1(internalCfg)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return fmt.Errorf(&quot;Mode1 扫描失败: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;fmt.Printf(&quot;Mode1 扫描完成，共找到 %d 个漏洞条目\n&quot;, len(results))&#10;&#9;case &quot;mode2&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode2（模糊）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;case &quot;mode3&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode3（通用）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;default:&#10;&#9;&#9;return errors.New(&quot;unsupported mode&quot;)&#10;&#9;}&#10;&#10;&#9;// Reporter 集成点（占位）&#10;&#9;//if cfg.ReportEnabled {&#10;&#9;//&#9;// 目前这里仅为占位提示 —— 实际应调用 internal/reporter 生成并保存报告。&#10;&#9;//&#9;// 示例伪代码：&#10;&#9;//&#9;// reportManager := reporter.New(cfg.ReportOut)&#10;&#9;//&#9;// meta, err := reportManager.Generate(ctx, scanResult, cfg.ReportFormats)&#10;&#9;//&#9;// if err != nil { log... }&#10;&#9;//&#9;// if cfg.ReportNotify { reportManager.Notify(meta) }&#10;&#9;//&#9;fmt.Printf(&quot;报告已启用 → 格式: %v, 输出: %s\n&quot;, cfg.ReportFormats, cfg.ReportOut)&#10;&#9;//}&#10;&#9;return nil&#10;}&#10;&#10;// 小帮助函数：PrintFatal 将错误打印到 stderr 并以非零代码退出。&#10;func PrintFatal(err error) {&#10;&#9;if err == nil {&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;fmt.Fprintln(os.Stderr, &quot;错误:&quot;, err)&#10;&#9;os.Exit(1)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/core/mode1.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/core/mode1.go" />
              <option name="originalContent" value="package core&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/cmd&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/types&quot;&#10;)&#10;&#10;// Mode1Scan 扫描合约并返回原始 AI 输出（占位实现）&#10;func Mode1Scan(contract types.Contract, prompt string, expCode string, cfg *cmd.CLIConfig) (string, error) {&#10;&#9;// TODO: 实际扫描逻辑，例如调用 AI 或分析 EXP&#10;&#9;return fmt.Sprintf(&quot;Mock AI 输出 for %s&quot;, contract.Address), nil&#10;}&#10;" />
              <option name="updatedContent" value="package core&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;)&#10;&#10;// Mode1Scan 扫描合约并返回原始 AI 输出（占位实现）&#10;func Mode1Scan(contract internal.Contract, prompt string, expCode string, cfg internal.ScanConfig) (string, error) {&#10;&#9;// TODO: 实际扫描逻辑，例如调用 AI 或分析 EXP&#10;&#9;return fmt.Sprintf(&quot;Mock AI 输出 for %s&quot;, contract.Address), nil&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/handler/mode1_targeted.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/handler/mode1_targeted.go" />
              <option name="originalContent" value="package handler&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/cmd&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;&quot;go/types&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;//&quot;github.com/admi-n/solidity-Excavator/src/cmd&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/ai/parser&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/core&quot;&#10;)&#10;&#10;// RunMode1 执行 Mode1 定向扫描&#10;func RunMode1(cfg internal.ScanConfig) ([]ai.ScanResult, error) {&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Println(&quot;[Mode1] 启动定向扫描...&quot;)&#10;&#9;}&#10;&#10;&#9;// 1️⃣ 获取目标合约列表&#10;&#9;targets, err := loadTargets(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;[Mode1] 加载目标失败: %w&quot;, err)&#10;&#9;}&#10;&#9;if len(targets) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;[Mode1] 未找到扫描目标&quot;)&#10;&#9;}&#10;&#10;&#9;var results []ai.ScanResult&#10;&#10;&#9;// 2️⃣ 遍历每个合约&#10;&#9;for _, contract := range targets {&#10;&#9;&#9;if cfg.Verbose {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 扫描合约: %s\n&quot;, contract.Address)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2a. 构建 Prompt&#10;&#9;&#9;prompt := buildPrompt(cfg, contract)&#10;&#9;&#9;// 2b. 加载漏洞复现 EXP (占位)&#10;&#9;&#9;expCode := loadExp(cfg.Strategy)&#10;&#10;&#9;&#9;// 2c. 调用 Core 层执行扫描&#10;&#9;&#9;rawOutput, err := core.Mode1Scan(contract, prompt, expCode, cfg)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 警告: 扫描合约 %s 失败: %v\n&quot;, contract.Address, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2d. 调用 AI Parser 将原始输出转换为 ScanResult&#10;&#9;&#9;structured, err := ai.Parser.Parse(rawOutput)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 警告: 解析合约 %s 输出失败: %v\n&quot;, contract.Address, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;results = append(results, structured...)&#10;&#10;&#9;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;}&#10;&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;[Mode1] 扫描完成，找到 %d 个漏洞条目\n&quot;, len(results))&#10;&#9;}&#10;&#10;&#9;return results, nil&#10;}&#10;&#10;// loadTargets 占位函数：根据 cfg.TargetSource 获取目标合约列表&#10;func loadTargets(cfg *cmd.CLIConfig) ([]types.Contract, error) {&#10;&#9;// TODO: 根据 cfg.TargetSource == &quot;db&quot; 或 &quot;file&quot; 加载真实数据&#10;&#9;mock := []types.Contract{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Address: &quot;0xDEADBEEF...&quot;,&#10;&#9;&#9;&#9;Code:    &quot;contract Mock { function test() public {} }&quot;,&#10;&#9;&#9;},&#10;&#9;}&#10;&#9;return mock, nil&#10;}&#10;&#10;// buildPrompt 占位函数&#10;func buildPrompt(cfg *cmd.CLIConfig, contract types.Contract) string {&#10;&#9;return fmt.Sprintf(&quot;请分析合约 %s 的漏洞，使用策略 %s&quot;, contract.Address, cfg.Strategy)&#10;}&#10;&#10;// loadExp 占位函数&#10;func loadExp(strategy string) string {&#10;&#9;return &quot;// 漏洞复现代码占位&quot;&#10;}&#10;" />
              <option name="updatedContent" value="package handler&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal&quot;&#10;&#9;parser &quot;github.com/admi-n/solidity-Excavator/src/internal/ai/parser&quot;&#10;&#9;&quot;github.com/admi-n/solidity-Excavator/src/internal/core&quot;&#10;)&#10;&#10;// RunMode1 执行 Mode1 定向扫描&#10;func RunMode1(cfg internal.ScanConfig) ([]parser.ScanResult, error) {&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Println(&quot;[Mode1] 启动定向扫描...&quot;)&#10;&#9;}&#10;&#10;&#9;// 1️⃣ 获取目标合约列表&#10;&#9;targets, err := loadTargets(cfg)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;[Mode1] 加载目标失败: %w&quot;, err)&#10;&#9;}&#10;&#9;if len(targets) == 0 {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;[Mode1] 未找到扫描目标&quot;)&#10;&#9;}&#10;&#10;&#9;var results []parser.ScanResult&#10;&#10;&#9;// 2️⃣ 遍历每个合约&#10;&#9;for _, contract := range targets {&#10;&#9;&#9;if cfg.Verbose {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 扫描合约: %s\n&quot;, contract.Address)&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2a. 构建 Prompt&#10;&#9;&#9;prompt := buildPrompt(cfg, contract)&#10;&#9;&#9;// 2b. 加载漏洞复现 EXP (占位)&#10;&#9;&#9;expCode := loadExp(cfg.Strategy)&#10;&#10;&#9;&#9;// 2c. 调用 Core 层执行扫描&#10;&#9;&#9;rawOutput, err := core.Mode1Scan(contract, prompt, expCode, cfg)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 警告: 扫描合约 %s 失败: %v\n&quot;, contract.Address, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 2d. 调用 AI Parser 将原始输出转换为 ScanResult&#10;&#9;&#9;structured, err := parser.Parser.Parse(rawOutput)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;[Mode1] 警告: 解析合约 %s 输出失败: %v\n&quot;, contract.Address, err)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;results = append(results, structured...)&#10;&#10;&#9;&#9;time.Sleep(100 * time.Millisecond)&#10;&#9;}&#10;&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;[Mode1] 扫描完成，找到 %d 个漏洞条目\n&quot;, len(results))&#10;&#9;}&#10;&#10;&#9;return results, nil&#10;}&#10;&#10;// loadTargets 占位函数：根据 cfg.TargetSource 获取目标合约列表&#10;func loadTargets(cfg internal.ScanConfig) ([]internal.Contract, error) {&#10;&#9;// TODO: 根据 cfg.TargetSource == &quot;db&quot; 或 &quot;file&quot; 加载真实数据&#10;&#9;mock := []internal.Contract{&#10;&#9;&#9;{&#10;&#9;&#9;&#9;Address: &quot;0xDEADBEEF...&quot;,&#10;&#9;&#9;&#9;Code:    &quot;contract Mock { function test() public {} }&quot;,&#10;&#9;&#9;},&#10;&#9;}&#10;&#9;return mock, nil&#10;}&#10;&#10;// buildPrompt 占位函数&#10;func buildPrompt(cfg internal.ScanConfig, contract internal.Contract) string {&#10;&#9;return fmt.Sprintf(&quot;请分析合约 %s 的漏洞，使用策略 %s&quot;, contract.Address, cfg.Strategy)&#10;}&#10;&#10;// loadExp 占位函数&#10;func loadExp(strategy string) string {&#10;&#9;return &quot;// 漏洞复现代码占位&quot;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/internal/types.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/internal/types.go" />
              <option name="originalContent" value="package internal&#10;&#10;import &quot;time&quot;&#10;&#10;type ScanConfig struct {&#10;&#9;AIProvider   string&#10;&#9;Mode         string&#10;&#9;Strategy     string&#10;&#9;TargetSource string&#10;&#9;TargetFile   string&#10;&#9;Chain        string&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#9;BlockRange   *BlockRange&#10;}&#10;&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;" />
              <option name="updatedContent" value="package internal&#10;&#10;import &quot;time&quot;&#10;&#10;type ScanConfig struct {&#10;&#9;AIProvider   string&#10;&#9;Mode         string&#10;&#9;Strategy     string&#10;&#9;TargetSource string&#10;&#9;TargetFile   string&#10;&#9;Chain        string&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;&#9;BlockRange   *BlockRange&#10;}&#10;&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;// 新增：表示待扫描的合约基础信息&#10;type Contract struct {&#10;&#9;Address string&#10;&#9;Code    string&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>