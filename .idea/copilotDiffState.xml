<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/cmd/cli.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/cmd/cli.go" />
              <option name="originalContent" value="package cmd&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;flag&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// CLIConfig holds parsed CLI options and normalized fields for the scanner to consume.&#10;type CLIConfig struct {&#10;&#9;AIProvider   string // e.g. chatgpt5&#10;&#9;Mode         string // mode1 | mode2 | mode3&#10;&#9;Strategy     string // e.g. hourglass-vul or &quot;all&quot;&#10;&#9;TargetSource string // &quot;db&quot; or &quot;file&quot; - where to pull target list from&#10;&#9;BlockRange   *BlockRange&#10;&#9;TargetFile   string // path to YAML containing addresses / batches&#10;&#9;Chain        string // eth | bsc | arb&#10;&#9;DBDSN        string // optional DB connection string&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;}&#10;&#10;// BlockRange simple structure for start-end block ranges&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;func (b *BlockRange) String() string {&#10;&#9;if b == nil {&#10;&#9;&#9;return &quot;&quot;&#10;&#9;}&#10;&#9;return fmt.Sprintf(&quot;%d-%d&quot;, b.Start, b.End)&#10;}&#10;&#10;// parseBlockRange parses strings like &quot;1-220234&quot; or &quot;1000-&quot; (open end) and returns BlockRange.&#10;func parseBlockRange(s string) (*BlockRange, error) {&#10;&#9;if strings.TrimSpace(s) == &quot;&quot; {&#10;&#9;&#9;return nil, nil&#10;&#9;}&#10;&#9;parts := strings.Split(s, &quot;-&quot;)&#10;&#9;if len(parts) != 2 {&#10;&#9;&#9;return nil, errors.New(&quot;invalid block range format, expected start-end&quot;)&#10;&#9;}&#10;&#9;startStr := strings.TrimSpace(parts[0])&#10;&#9;endStr := strings.TrimSpace(parts[1])&#10;&#9;var br BlockRange&#10;&#9;if startStr == &quot;&quot; {&#10;&#9;&#9;return nil, errors.New(&quot;start block required&quot;)&#10;&#9;}&#10;&#9;start, err := strconv.ParseUint(startStr, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid start block: %w&quot;, err)&#10;&#9;}&#10;&#9;br.Start = start&#10;&#9;if endStr == &quot;&quot; {&#10;&#9;&#9;br.End = ^uint64(0) // max uint64 to indicate open-ended&#10;&#9;} else {&#10;&#9;&#9;end, err := strconv.ParseUint(endStr, 10, 64)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;invalid end block: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if end &lt; start {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;end block must be &gt;= start block&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;br.End = end&#10;&#9;}&#10;&#9;return &amp;br, nil&#10;}&#10;&#10;// Validate checks the CLIConfig for required/consistent inputs.&#10;func (c *CLIConfig) Validate() error {&#10;&#9;if c.AIProvider == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-ai is required (e.g. -ai chatgpt5)&quot;)&#10;&#9;}&#10;&#9;if c.Mode == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-m (mode) is required: mode1|mode2|mode3&quot;)&#10;&#9;}&#10;&#9;if c.Mode != &quot;mode1&quot; &amp;&amp; c.Mode != &quot;mode2&quot; &amp;&amp; c.Mode != &quot;mode3&quot; {&#10;&#9;&#9;return errors.New(&quot;-m must be one of: mode1, mode2, mode3&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource != &quot;db&quot; &amp;&amp; c.TargetSource != &quot;file&quot; {&#10;&#9;&#9;return errors.New(&quot;-t must be either 'db' or 'file'&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource == &quot;file&quot; &amp;&amp; c.TargetFile == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-t-file is required when -t=file&quot;)&#10;&#9;}&#10;&#9;if c.Chain == &quot;&quot; {&#10;&#9;&#9;c.Chain = &quot;eth&quot; // default&#10;&#9;}&#10;&#9;if c.Concurrency &lt;= 0 {&#10;&#9;&#9;c.Concurrency = 4&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// ParseFlags parses os.Args and returns a CLIConfig or an error. Intended to be called from main.&#10;func ParseFlags() (*CLIConfig, error) {&#10;&#9;fs := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)&#10;&#9;fs.Usage = func() {&#10;&#9;&#9;w := fs.Output()&#10;&#9;&#9;fmt.Fprintln(w, &quot;Usage: excavator -ai &lt;provider&gt; -m &lt;mode&gt; [options]&quot;)&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;Options:&quot;)&#10;&#9;&#9;fs.PrintDefaults()&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;Examples:&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s hourglass-vul -t file -t-file ./data/source_contracts/sample.yaml -c eth&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s all -t db -t-block 1-220234 -c eth&quot;)&#10;&#9;}&#10;&#10;&#9;ai := fs.String(&quot;ai&quot;, &quot;&quot;, &quot;AI provider to use (e.g. chatgpt5)&quot;)&#10;&#9;mode := fs.String(&quot;m&quot;, &quot;&quot;, &quot;Mode to run: mode1 | mode2 | mode3&quot;)&#10;&#9;strategy := fs.String(&quot;s&quot;, &quot;all&quot;, &quot;Strategy/prompt name in strategy/prompts/&lt;mode&gt;/ (or 'all')&quot;)&#10;&#9;target := fs.String(&quot;t&quot;, &quot;db&quot;, &quot;Target source: 'db' or 'file' (default db)&quot;)&#10;&#9;blockRange := fs.String(&quot;t-block&quot;, &quot;&quot;, &quot;Block range for scanning (format start-end, e.g. 1-220234)&quot;)&#10;&#9;tfile := fs.String(&quot;t-file&quot;, &quot;&quot;, &quot;YAML file path when -t=file; can be a directory for batching&quot;)&#10;&#9;chain := fs.String(&quot;c&quot;, &quot;eth&quot;, &quot;Chain to scan: eth | bsc | arb (default eth)&quot;)&#10;&#9;dsn := fs.String(&quot;db-dsn&quot;, &quot;&quot;, &quot;Database DSN/connection string (optional) when -t=db&quot;)&#10;&#9;concurrency := fs.Int(&quot;concurrency&quot;, 4, &quot;Worker concurrency&quot;)&#10;&#9;verbose := fs.Bool(&quot;v&quot;, false, &quot;Verbose output&quot;)&#10;&#9;timeout := fs.Duration(&quot;timeout&quot;, 30*time.Second, &quot;Per-AI request timeout&quot;)&#10;&#10;&#9;if err := fs.Parse(os.Args[1:]); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;cfg := &amp;CLIConfig{&#10;&#9;&#9;AIProvider:   strings.TrimSpace(*ai),&#10;&#9;&#9;Mode:         strings.TrimSpace(*mode),&#10;&#9;&#9;Strategy:     strings.TrimSpace(*strategy),&#10;&#9;&#9;TargetSource: strings.TrimSpace(*target),&#10;&#9;&#9;TargetFile:   strings.TrimSpace(*tfile),&#10;&#9;&#9;Chain:        strings.TrimSpace(*chain),&#10;&#9;&#9;DBDSN:        strings.TrimSpace(*dsn),&#10;&#9;&#9;Concurrency:  *concurrency,&#10;&#9;&#9;Verbose:      *verbose,&#10;&#9;&#9;Timeout:      *timeout,&#10;&#9;}&#10;&#10;&#9;if strings.TrimSpace(*blockRange) != &quot;&quot; {&#10;&#9;&#9;br, err := parseBlockRange(*blockRange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;cfg.BlockRange = br&#10;&#9;}&#10;&#10;&#9;// normalize target source&#10;&#9;cfg.TargetSource = strings.ToLower(cfg.TargetSource)&#10;&#9;if cfg.TargetSource == &quot;yaml&quot; {&#10;&#9;&#9;cfg.TargetSource = &quot;file&quot; // accept yaml alias&#10;&#9;}&#10;&#10;&#9;// if file path provided but not absolute, make it relative to cwd&#10;&#9;if cfg.TargetFile != &quot;&quot; {&#10;&#9;&#9;if !filepath.IsAbs(cfg.TargetFile) {&#10;&#9;&#9;&#9;cwd, _ := os.Getwd()&#10;&#9;&#9;&#9;cfg.TargetFile = filepath.Join(cwd, cfg.TargetFile)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if err := cfg.Validate(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return cfg, nil&#10;}&#10;&#10;// Run is a convenience wrapper that parses flags and dispatches to the appropriate handler.&#10;// Replace the placeholder handler calls with your actual internal/core logic.&#10;func Run() error {&#10;&#9;cfg, err := ParseFlags()&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;Running Excavator with config: %+v\n&quot;, cfg)&#10;&#9;}&#10;&#10;&#9;// TODO: integrate with internal/core handlers. Below are example dispatches.&#10;&#9;switch cfg.Mode {&#10;&#9;case &quot;mode1&quot;:&#10;&#9;&#9;// call your internal handler, e.g. internal/handler.Mode1Targeted(cfg)&#10;&#9;&#9;fmt.Println(&quot;Dispatching to mode1 (targeted) handler — implement call to internal/handler&quot;)&#10;&#9;case &quot;mode2&quot;:&#10;&#9;&#9;fmt.Println(&quot;Dispatching to mode2 (fuzzy) handler — implement call to internal/handler&quot;)&#10;&#9;case &quot;mode3&quot;:&#10;&#9;&#9;fmt.Println(&quot;Dispatching to mode3 (general) handler — implement call to internal/handler&quot;)&#10;&#9;default:&#10;&#9;&#9;return errors.New(&quot;unsupported mode&quot;)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// Small helper: PrintFatal prints the error to stderr and exits with non-zero code.&#10;func PrintFatal(err error) {&#10;&#9;if err == nil {&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;fmt.Fprintln(os.Stderr, &quot;ERROR:&quot;, err)&#10;&#9;os.Exit(1)&#10;}&#10;" />
              <option name="updatedContent" value="package cmd&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;flag&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;os&quot;&#10;&#9;&quot;path/filepath&quot;&#10;&#9;&quot;strconv&quot;&#10;&#9;&quot;strings&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// CLIConfig 保存解析好的 CLI 选项以及供扫描器使用的规范化字段。&#10;type CLIConfig struct {&#10;&#9;AIProvider   string // 例如 chatgpt5&#10;&#9;Mode         string // mode1 | mode2 | mode3&#10;&#9;Strategy     string // 例如 hourglass-vul 或 &quot;all&quot;&#10;&#9;TargetSource string // &quot;db&quot; 或 &quot;file&quot; - 从哪里获取目标列表&#10;&#9;BlockRange   *BlockRange&#10;&#9;TargetFile   string // 包含地址/批次的 YAML 路径&#10;&#9;Chain        string // eth | bsc | arb&#10;&#9;DBDSN        string // 可选的数据库连接字符串&#10;&#9;Concurrency  int&#10;&#9;Verbose      bool&#10;&#9;Timeout      time.Duration&#10;}&#10;&#10;// BlockRange 简单的起止区块范围结构&#10;type BlockRange struct {&#10;&#9;Start uint64&#10;&#9;End   uint64&#10;}&#10;&#10;func (b *BlockRange) String() string {&#10;&#9;if b == nil {&#10;&#9;&#9;return &quot;&quot;&#10;&#9;}&#10;&#9;return fmt.Sprintf(&quot;%d-%d&quot;, b.Start, b.End)&#10;}&#10;&#10;// parseBlockRange 解析类似 &quot;1-220234&quot; 或 &quot;1000-&quot;（开放结束）的字符串并返回 BlockRange。&#10;func parseBlockRange(s string) (*BlockRange, error) {&#10;&#9;if strings.TrimSpace(s) == &quot;&quot; {&#10;&#9;&#9;return nil, nil&#10;&#9;}&#10;&#9;parts := strings.Split(s, &quot;-&quot;)&#10;&#9;if len(parts) != 2 {&#10;&#9;&#9;return nil, errors.New(&quot;invalid block range format, expected start-end&quot;)&#10;&#9;}&#10;&#9;startStr := strings.TrimSpace(parts[0])&#10;&#9;endStr := strings.TrimSpace(parts[1])&#10;&#9;var br BlockRange&#10;&#9;if startStr == &quot;&quot; {&#10;&#9;&#9;return nil, errors.New(&quot;start block required&quot;)&#10;&#9;}&#10;&#9;start, err := strconv.ParseUint(startStr, 10, 64)&#10;&#9;if err != nil {&#10;&#9;&#9;return nil, fmt.Errorf(&quot;invalid start block: %w&quot;, err)&#10;&#9;}&#10;&#9;br.Start = start&#10;&#9;if endStr == &quot;&quot; {&#10;&#9;&#9;br.End = ^uint64(0) // max uint64 to indicate open-ended&#10;&#9;} else {&#10;&#9;&#9;end, err := strconv.ParseUint(endStr, 10, 64)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, fmt.Errorf(&quot;invalid end block: %w&quot;, err)&#10;&#9;&#9;}&#10;&#9;&#9;if end &lt; start {&#10;&#9;&#9;&#9;return nil, errors.New(&quot;end block must be &gt;= start block&quot;)&#10;&#9;&#9;}&#10;&#9;&#9;br.End = end&#10;&#9;}&#10;&#9;return &amp;br, nil&#10;}&#10;&#10;// Validate 检查 CLIConfig 的必需/一致性输入。&#10;func (c *CLIConfig) Validate() error {&#10;&#9;if c.AIProvider == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-ai is required (e.g. -ai chatgpt5)&quot;)&#10;&#9;}&#10;&#9;if c.Mode == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-m (mode) is required: mode1|mode2|mode3&quot;)&#10;&#9;}&#10;&#9;if c.Mode != &quot;mode1&quot; &amp;&amp; c.Mode != &quot;mode2&quot; &amp;&amp; c.Mode != &quot;mode3&quot; {&#10;&#9;&#9;return errors.New(&quot;-m must be one of: mode1, mode2, mode3&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource != &quot;db&quot; &amp;&amp; c.TargetSource != &quot;file&quot; {&#10;&#9;&#9;return errors.New(&quot;-t must be either 'db' or 'file'&quot;)&#10;&#9;}&#10;&#9;if c.TargetSource == &quot;file&quot; &amp;&amp; c.TargetFile == &quot;&quot; {&#10;&#9;&#9;return errors.New(&quot;-t-file is required when -t=file&quot;)&#10;&#9;}&#10;&#9;if c.Chain == &quot;&quot; {&#10;&#9;&#9;c.Chain = &quot;eth&quot; // default&#10;&#9;}&#10;&#9;if c.Concurrency &lt;= 0 {&#10;&#9;&#9;c.Concurrency = 4&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// ParseFlags 解析 os.Args 并返回 CLIConfig 或错误。用于从 main 调用。&#10;func ParseFlags() (*CLIConfig, error) {&#10;&#9;fs := flag.NewFlagSet(os.Args[0], flag.ContinueOnError)&#10;&#9;fs.Usage = func() {&#10;&#9;&#9;w := fs.Output()&#10;&#9;&#9;fmt.Fprintln(w, &quot;用法: excavator -ai &lt;provider&gt; -m &lt;mode&gt; [选项]&quot;)&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;选项:&quot;)&#10;&#9;&#9;fs.PrintDefaults()&#10;&#9;&#9;fmt.Fprintln(w)&#10;&#9;&#9;fmt.Fprintln(w, &quot;示例:&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s hourglass-vul -t file -t-file ./data/source_contracts/sample.yaml -c eth&quot;)&#10;&#9;&#9;fmt.Fprintln(w, &quot;  excavator -ai chatgpt5 -m mode1 -s all -t db -t-block 1-220234 -c eth&quot;)&#10;&#9;}&#10;&#10;&#9;ai := fs.String(&quot;ai&quot;, &quot;&quot;, &quot;AI provider to use (e.g. chatgpt5)&quot;)&#10;&#9;mode := fs.String(&quot;m&quot;, &quot;&quot;, &quot;Mode to run: mode1 | mode2 | mode3&quot;)&#10;&#9;strategy := fs.String(&quot;s&quot;, &quot;all&quot;, &quot;Strategy/prompt name in strategy/prompts/&lt;mode&gt;/ (or 'all')&quot;)&#10;&#9;target := fs.String(&quot;t&quot;, &quot;db&quot;, &quot;Target source: 'db' or 'file' (default db)&quot;)&#10;&#9;blockRange := fs.String(&quot;t-block&quot;, &quot;&quot;, &quot;Block range for scanning (format start-end, e.g. 1-220234)&quot;)&#10;&#9;tfile := fs.String(&quot;t-file&quot;, &quot;&quot;, &quot;YAML file path when -t=file; can be a directory for batching&quot;)&#10;&#9;chain := fs.String(&quot;c&quot;, &quot;eth&quot;, &quot;Chain to scan: eth | bsc | arb (default eth)&quot;)&#10;&#9;dsn := fs.String(&quot;db-dsn&quot;, &quot;&quot;, &quot;Database DSN/connection string (optional) when -t=db&quot;)&#10;&#9;concurrency := fs.Int(&quot;concurrency&quot;, 4, &quot;Worker concurrency&quot;)&#10;&#9;verbose := fs.Bool(&quot;v&quot;, false, &quot;Verbose output&quot;)&#10;&#9;timeout := fs.Duration(&quot;timeout&quot;, 30*time.Second, &quot;Per-AI request timeout&quot;)&#10;&#10;&#9;if err := fs.Parse(os.Args[1:]); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;cfg := &amp;CLIConfig{&#10;&#9;&#9;AIProvider:   strings.TrimSpace(*ai),&#10;&#9;&#9;Mode:         strings.TrimSpace(*mode),&#10;&#9;&#9;Strategy:     strings.TrimSpace(*strategy),&#10;&#9;&#9;TargetSource: strings.TrimSpace(*target),&#10;&#9;&#9;TargetFile:   strings.TrimSpace(*tfile),&#10;&#9;&#9;Chain:        strings.TrimSpace(*chain),&#10;&#9;&#9;DBDSN:        strings.TrimSpace(*dsn),&#10;&#9;&#9;Concurrency:  *concurrency,&#10;&#9;&#9;Verbose:      *verbose,&#10;&#9;&#9;Timeout:      *timeout,&#10;&#9;}&#10;&#10;&#9;if strings.TrimSpace(*blockRange) != &quot;&quot; {&#10;&#9;&#9;br, err := parseBlockRange(*blockRange)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return nil, err&#10;&#9;&#9;}&#10;&#9;&#9;cfg.BlockRange = br&#10;&#9;}&#10;&#10;&#9;// normalize target source&#10;&#9;cfg.TargetSource = strings.ToLower(cfg.TargetSource)&#10;&#9;if cfg.TargetSource == &quot;yaml&quot; {&#10;&#9;&#9;cfg.TargetSource = &quot;file&quot; // accept yaml alias&#10;&#9;}&#10;&#10;&#9;// 如果提供了文件路径但不是绝对路径，则将其转为相对于当前工作目录&#10;&#9;if cfg.TargetFile != &quot;&quot; {&#10;&#9;&#9;if !filepath.IsAbs(cfg.TargetFile) {&#10;&#9;&#9;&#9;cwd, _ := os.Getwd()&#10;&#9;&#9;&#9;cfg.TargetFile = filepath.Join(cwd, cfg.TargetFile)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;if err := cfg.Validate(); err != nil {&#10;&#9;&#9;return nil, err&#10;&#9;}&#10;&#10;&#9;return cfg, nil&#10;}&#10;&#10;// Run 是一个便利包装，解析 flags 并分派到相应处理器。&#10;// 用你实际的内部/核心逻辑替换占位处理调用。&#10;func Run() error {&#10;&#9;cfg, err := ParseFlags()&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;if cfg.Verbose {&#10;&#9;&#9;fmt.Printf(&quot;使用配置运行 Excavator: %+v\n&quot;, cfg)&#10;&#9;}&#10;&#10;&#9;// TODO: 与内部/核心处理器集成。下面为示例分派。&#10;&#9;switch cfg.Mode {&#10;&#9;case &quot;mode1&quot;:&#10;&#9;&#9;// call your internal handler, e.g. internal/handler.Mode1Targeted(cfg)&#10;&#9;&#9;fmt.Println(&quot;分派到 mode1（定向）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;case &quot;mode2&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode2（模糊）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;case &quot;mode3&quot;:&#10;&#9;&#9;fmt.Println(&quot;分派到 mode3（通用）处理器 — 请实现调用 internal/handler&quot;)&#10;&#9;default:&#10;&#9;&#9;return errors.New(&quot;unsupported mode&quot;)&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// 小帮助函数：PrintFatal 将错误打印到 stderr 并以非零代码退出。&#10;func PrintFatal(err error) {&#10;&#9;if err == nil {&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;fmt.Fprintln(os.Stderr, &quot;错误:&quot;, err)&#10;&#9;os.Exit(1)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>